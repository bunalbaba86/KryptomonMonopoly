<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kryptomon Monopoly - Ultimate Edition</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
  color: #fff;
  min-height: 100vh;
  overflow-x: hidden;
}

.container {
  max-width: 100%;
  margin: 0 auto;
  padding: 10px;
}

h1 {
  text-align: center;
  color: #00f5ff;
  font-size: clamp(1.5rem, 5vw, 3rem);
  margin-bottom: 20px;
  text-shadow: 0 0 30px #00f5ff;
  animation: titleGlow 2s ease-in-out infinite alternate;
  font-weight: 900;
}

@keyframes titleGlow {
  from { text-shadow: 0 0 30px #00f5ff; }
  to { text-shadow: 0 0 50px #00f5ff; }
}

/* Menu */
.menu {
  text-align: center;
  padding: 60px 30px;
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.4), rgba(22, 33, 62, 0.4));
  border-radius: 40px;
  backdrop-filter: blur(15px);
  border: 3px solid rgba(0, 245, 255, 0.4);
  box-shadow: 0 20px 60px rgba(0, 245, 255, 0.2);
}

.menu button {
  background: linear-gradient(45deg, #00f5ff, #0080ff);
  border: none;
  padding: 20px 40px;
  margin: 15px;
  font-size: 18px;
  color: white;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.4s ease;
  box-shadow: 0 10px 35px rgba(0, 245, 255, 0.4);
  font-weight: bold;
  min-width: 180px;
  position: relative;
  overflow: hidden;
}

.menu button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.5s;
}

.menu button:hover::before {
  left: 100%;
}

.menu button:hover {
  transform: translateY(-3px) scale(1.05);
  box-shadow: 0 20px 50px rgba(0, 245, 255, 0.6);
}

/* Game Layout */
.game-container {
  display: none;
}

.game-layout {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 25px;
  max-width: 100%;
}

/* Game Board */
.board-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.board {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 3px;
  width: min(90vw, 520px);
  height: min(90vw, 520px);
  background: linear-gradient(45deg, #0f1419, #1a1a2e);
  border: 5px solid #00f5ff;
  border-radius: 20px;
  padding: 12px;
  box-shadow: 0 0 40px rgba(0, 245, 255, 0.7), inset 0 0 20px rgba(0, 245, 255, 0.1);
  margin-bottom: 25px;
  position: relative;
}

.board::before {
  content: '';
  position: absolute;
  top: -5px;
  left: -5px;
  right: -5px;
  bottom: -5px;
  background: linear-gradient(45deg, #00f5ff, #0080ff, #00f5ff);
  border-radius: 20px;
  z-index: -1;
  animation: borderGlow 3s ease-in-out infinite alternate;
}

@keyframes borderGlow {
  from { opacity: 0.7; }
  to { opacity: 1; }
}

.cell {
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 5px;
  position: relative;
  border: 2px solid rgba(0, 245, 255, 0.3);
  transition: all 0.3s ease;
  backdrop-filter: blur(5px);
}

.cell.empty {
  background: transparent;
  border: none;
}

.cell:not(.empty):hover {
  border-color: #00f5ff;
  box-shadow: 0 0 20px rgba(0, 245, 255, 0.6);
  transform: scale(1.02);
}

.cell-name {
  font-size: clamp(8px, 2.2vw, 11px);
  font-weight: bold;
  text-align: center;
  color: #fff;
  line-height: 1.1;
  margin-bottom: 4px;
  text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
}

.cell-rent {
  background: linear-gradient(45deg, #00f5ff, #0080ff);
  color: #000;
  padding: 2px 5px;
  border-radius: 5px;
  font-size: clamp(7px, 1.8vw, 9px);
  font-weight: bold;
  margin-top: auto;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.cell-building {
  font-size: clamp(10px, 2.5vw, 14px);
  margin-top: 2px;
  text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
  filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5));
}

.owner-tag {
  position: absolute;
  top: 3px;
  right: 3px;
  padding: 2px 4px;
  border-radius: 5px;
  font-size: clamp(7px, 1.8vw, 9px);
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.owner-player { 
  background: linear-gradient(45deg, #ff4757, #ff6b6b); 
  color: #fff; 
  border: 1px solid #fff;
}
.owner-cpu { 
  background: linear-gradient(45deg, #2ed573, #00ff41); 
  color: #000; 
  border: 1px solid #000;
}

.player-token {
  position: absolute;
  width: clamp(22px, 5.5vw, 28px);
  height: clamp(22px, 5.5vw, 28px);
  border-radius: 50%;
  border: 3px solid #fff;
  transition: all 0.8s ease;
  z-index: 20;
  background-size: cover;
  background-position: center;
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.9);
}

.token-player {
  background-image: url('kryptomon.png');
  bottom: 4px;
  left: 4px;
  border-color: #00f5ff;
  box-shadow: 0 0 15px rgba(0, 245, 255, 0.8);
}

.token-cpu {
  background-image: url('kryptomon2.png');
  bottom: 4px;
  right: 4px;
  border-color: #2ed573;
  box-shadow: 0 0 15px rgba(46, 213, 115, 0.8);
}

/* START cell special styling - FIXED! */
.cell.start {
  background: linear-gradient(145deg, #32cd32, #00ff41) !important;
  color: #000 !important;
  border: 4px solid #32cd32 !important;
  box-shadow: 0 0 30px rgba(50, 205, 50, 0.9) !important;
  position: relative;
}

.cell.start::before {
  content: '';
  position: absolute;
  inset: -2px;
  background: linear-gradient(45deg, #32cd32, #00ff00, #32cd32);
  border-radius: 10px;
  z-index: -1;
  animation: startGlow 2s ease-in-out infinite alternate;
}

@keyframes startGlow {
  from { opacity: 0.8; }
  to { opacity: 1; }
}

.cell.start .cell-name {
  color: #000 !important;
  font-size: clamp(10px, 2.8vw, 14px) !important;
  font-weight: 900 !important;
  text-shadow: 0 0 20px rgba(255, 255, 255, 1) !important;
  background: rgba(255, 255, 255, 0.4) !important;
  padding: 3px 6px !important;
  border-radius: 6px !important;
  border: 1px solid rgba(0, 0, 0, 0.2) !important;
}

.cell.start .player-token {
  border-width: 4px !important;
  box-shadow: 0 0 25px rgba(255, 255, 255, 1) !important;
  z-index: 30 !important;
}

/* Other special cells */
.cell.jail {
  background: linear-gradient(145deg, #dc143c, #b22222);
  color: #fff;
  border-color: #b22222;
  box-shadow: 0 0 20px rgba(220, 20, 60, 0.5);
}

.cell.tax {
  background: linear-gradient(145deg, #ff69b4, #ff1493);
  color: #fff;
  border-color: #ff1493;
  box-shadow: 0 0 20px rgba(255, 20, 147, 0.5);
}

.cell.chance {
  background: linear-gradient(145deg, #9932cc, #8b008b);
  color: #fff;
  border-color: #8b008b;
  box-shadow: 0 0 20px rgba(153, 50, 204, 0.5);
}

.cell.airport {
  background: linear-gradient(145deg, #00ced1, #40e0d0);
  color: #000;
  border-color: #00ced1;
  box-shadow: 0 0 20px rgba(0, 206, 209, 0.5);
}

/* Property Element Styling */
.cell.fire {
  background: linear-gradient(145deg, #ff4500, #ff6347) !important;
  border-color: #ff4500 !important;
  box-shadow: 0 0 15px rgba(255, 69, 0, 0.4) !important;
}

.cell.water {
  background: linear-gradient(145deg, #1e90ff, #4169e1) !important;
  border-color: #1e90ff !important;
  box-shadow: 0 0 15px rgba(30, 144, 255, 0.4) !important;
}

.cell.earth {
  background: linear-gradient(145deg, #8b4513, #a0522d) !important;
  border-color: #8b4513 !important;
  box-shadow: 0 0 15px rgba(139, 69, 19, 0.4) !important;
}

.cell.air {
  background: linear-gradient(145deg, #87ceeb, #b0e0e6) !important;
  border-color: #87ceeb !important;
  box-shadow: 0 0 15px rgba(135, 206, 235, 0.4) !important;
}

.cell.ice {
  background: linear-gradient(145deg, #e0ffff, #b0e0e6) !important;
  border-color: #e0ffff !important;
  box-shadow: 0 0 15px rgba(224, 255, 255, 0.4) !important;
}

.cell.thunder {
  background: linear-gradient(145deg, #ffd700, #ffff00) !important;
  border-color: #ffd700 !important;
  box-shadow: 0 0 15px rgba(255, 215, 0, 0.4) !important;
}

.cell.dark {
  background: linear-gradient(145deg, #4b0082, #663399) !important;
  border-color: #4b0082 !important;
  box-shadow: 0 0 15px rgba(75, 0, 130, 0.4) !important;
}

.cell.crystal {
  background: linear-gradient(145deg, #da70d6, #ff69b4) !important;
  border-color: #da70d6 !important;
  box-shadow: 0 0 15px rgba(218, 112, 214, 0.4) !important;
}

/* Dice Section with Player Info */
.dice-section {
  display: flex;
  gap: 20px;
  align-items: center;
  justify-content: center;
  margin-bottom: 25px;
  padding: 20px;
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.4), rgba(22, 33, 62, 0.4));
  border-radius: 25px;
  backdrop-filter: blur(15px);
  border: 3px solid rgba(0, 245, 255, 0.4);
  width: 100%;
  max-width: 650px;
  box-shadow: 0 15px 45px rgba(0, 245, 255, 0.2);
}

/* Player Info - Left and Right of Dice */
.player-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 15px;
  border-radius: 18px;
  transition: all 0.5s ease;
  min-width: 130px;
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.6), rgba(22, 33, 62, 0.6));
  border: 3px solid rgba(0, 245, 255, 0.3);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.player-info.active {
  border-color: #00f5ff;
  box-shadow: 0 0 30px rgba(0, 245, 255, 0.6);
  transform: scale(1.08);
  background: linear-gradient(145deg, rgba(0, 245, 255, 0.1), rgba(0, 128, 255, 0.1));
}

.player-avatar {
  width: 55px;
  height: 55px;
  border-radius: 50%;
  border: 4px solid #00f5ff;
  background-size: cover;
  background-position: center;
  margin-bottom: 10px;
  box-shadow: 0 0 20px rgba(0, 245, 255, 0.6);
  transition: all 0.3s ease;
}

.player-avatar:hover {
  transform: scale(1.1);
  box-shadow: 0 0 25px rgba(0, 245, 255, 0.8);
}

.player-avatar.player { background-image: url('character.png'); }
.player-avatar.cpu { background-image: url('character2.png'); }

.player-name {
  font-size: 15px;
  font-weight: bold;
  margin-bottom: 6px;
  color: #00f5ff;
  text-align: center;
  text-shadow: 0 0 10px rgba(0, 245, 255, 0.5);
}

.player-money {
  font-size: 18px;
  color: #2ed573;
  margin-bottom: 4px;
  font-weight: bold;
  text-align: center;
  text-shadow: 0 0 10px rgba(46, 213, 115, 0.5);
}

.player-properties {
  font-size: 11px;
  color: #ccc;
  text-align: center;
}

.dice-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.dice-container {
  display: flex;
  gap: 12px;
}

.dice {
  width: clamp(55px, 13vw, 65px);
  height: clamp(55px, 13vw, 65px);
  background: linear-gradient(45deg, #00f5ff, #0080ff);
  border-radius: 15px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(22px, 5.5vw, 26px);
  font-weight: bold;
  color: white;
  cursor: pointer;
  transition: all 0.4s ease;
  box-shadow: 0 8px 25px rgba(0, 245, 255, 0.5);
  border: 3px solid #fff;
  position: relative;
  overflow: hidden;
}

.dice::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  transition: left 0.6s;
}

.dice:hover::before {
  left: 100%;
}

.dice:hover {
  transform: scale(1.15);
  box-shadow: 0 12px 35px rgba(0, 245, 255, 0.7);
}

.dice.rolling {
  animation: roll 0.8s ease-in-out;
}

@keyframes roll {
  0% { transform: rotate(0deg) scale(1); }
  25% { transform: rotate(90deg) scale(1.2); }
  50% { transform: rotate(180deg) scale(1.3); }
  75% { transform: rotate(270deg) scale(1.2); }
  100% { transform: rotate(360deg) scale(1); }
}

.roll-btn {
  background: linear-gradient(45deg, #ff6b6b, #ff8e53);
  border: none;
  padding: 15px 25px;
  color: white;
  border-radius: 25px;
  font-size: clamp(15px, 3.8vw, 17px);
  cursor: pointer;
  transition: all 0.4s ease;
  box-shadow: 0 8px 25px rgba(255, 107, 107, 0.5);
  font-weight: bold;
  min-width: 110px;
  position: relative;
  overflow: hidden;
}

.roll-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: left 0.5s;
}

.roll-btn:hover:not(:disabled)::before {
  left: 100%;
}

.roll-btn:hover:not(:disabled) {
  transform: translateY(-3px) scale(1.05);
  box-shadow: 0 15px 40px rgba(255, 107, 107, 0.7);
}

.roll-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Rest of the styles remain the same until the script section... */
/* Purchase Panel */
.purchase-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #00f5ff;
  border-radius: 20px;
  padding: 20px;
  z-index: 2000;
  display: none;
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  backdrop-filter: blur(20px);
  box-shadow: 0 0 50px rgba(0, 245, 255, 0.6);
  text-align: center;
}

.purchase-title {
  font-size: clamp(20px, 5vw, 24px);
  color: #00f5ff;
  margin-bottom: 15px;
  font-weight: bold;
}

.property-details {
  background: rgba(0, 0, 0, 0.4);
  padding: 12px;
  border-radius: 10px;
  margin: 12px 0;
  text-align: left;
  border: 1px solid rgba(0, 245, 255, 0.2);
  font-size: clamp(12px, 3vw, 14px);
}

.upgrade-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 10px;
  margin: 15px 0;
}

.upgrade-btn {
  background: linear-gradient(45deg, #ffa500, #ff8c00);
  border: none;
  padding: 12px 8px;
  color: white;
  border-radius: 10px;
  cursor: pointer;
  font-size: clamp(10px, 2.5vw, 12px);
  font-weight: bold;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
  min-height: 60px;
}

.upgrade-btn:hover:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(255, 165, 0, 0.5);
}

.upgrade-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.hotel-btn {
  background: linear-gradient(45deg, #ff1493, #dc143c);
}

.battle-btn {
  background: linear-gradient(45deg, #8b00ff, #4b0082);
  grid-column: 1 / -1;
  margin-top: 8px;
}

.skip-btn {
  background: linear-gradient(45deg, #666, #888);
  margin-top: 12px;
  padding: 10px 20px;
  font-size: clamp(14px, 3.5vw, 16px);
  border-radius: 15px;
  border: none;
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

/* Game Info */
.game-info {
  text-align: center;
  font-size: clamp(15px, 3.8vw, 19px);
  margin: 20px 0;
  color: #00f5ff;
  font-weight: bold;
  padding: 12px 18px;
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.4), rgba(22, 33, 62, 0.4));
  border-radius: 18px;
  border: 3px solid rgba(0, 245, 255, 0.4);
  backdrop-filter: blur(15px);
  max-width: 450px;
  width: 100%;
  box-shadow: 0 10px 30px rgba(0, 245, 255, 0.2);
  text-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
}

.back-btn {
  background: linear-gradient(45deg, #666, #888);
  border: none;
  padding: 12px 25px;
  color: white;
  border-radius: 18px;
  cursor: pointer;
  margin: 25px auto;
  display: block;
  font-size: clamp(15px, 3.8vw, 17px);
  font-weight: bold;
  transition: all 0.3s ease;
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
}

.back-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 35px rgba(0, 0, 0, 0.4);
}

/* Message Box and other panels styles remain the same... */
.message-box {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #00f5ff;
  border-radius: 15px;
  padding: 20px 25px;
  color: #fff;
  font-size: clamp(14px, 3.5vw, 16px);
  text-align: center;
  z-index: 2500;
  display: none;
  backdrop-filter: blur(15px);
  box-shadow: 0 0 50px rgba(0, 245, 255, 0.6);
  max-width: 80%;
  width: 300px;
}

/* Battle System */
.battle-arena {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #ff4757;
  border-radius: 20px;
  padding: 25px;
  z-index: 2500;
  display: none;
  width: 90%;
  max-width: 600px;
  backdrop-filter: blur(20px);
  box-shadow: 0 0 60px rgba(255, 71, 87, 0.8);
  text-align: center;
}

.battle-title {
  font-size: 24px;
  color: #ff4757;
  margin-bottom: 20px;
  font-weight: bold;
  text-shadow: 0 0 20px #ff4757;
}

.battle-field {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 20px 0;
  gap: 20px;
}

.battle-player {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

.battle-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background-size: cover;
  background-position: center;
  border: 4px solid #00f5ff;
  margin-bottom: 10px;
  transition: all 0.5s ease;
}

.battle-avatar.player { background-image: url('kryptomon.png'); }
.battle-avatar.cpu { background-image: url('kryptomon2.png'); }

.battle-avatar.attacking {
  animation: attack 0.8s ease-in-out;
}

.battle-avatar.defending {
  animation: defend 0.5s ease-in-out;
}

@keyframes attack {
  0% { transform: scale(1); }
  50% { transform: scale(1.2) translateX(20px); }
  100% { transform: scale(1); }
}

@keyframes defend {
  0% { transform: scale(1); }
  25% { transform: scale(0.9); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.hp-bar {
  width: 120px;
  height: 20px;
  background: #333;
  border: 2px solid #fff;
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 5px;
}

.hp-fill {
  height: 100%;
  background: linear-gradient(45deg, #2ed573, #00ff00);
  transition: width 0.5s ease;
  border-radius: 8px;
}

.hp-text {
  font-size: 14px;
  font-weight: bold;
  color: #fff;
}

.battle-vs {
  font-size: 28px;
  color: #ff4757;
  font-weight: bold;
  text-shadow: 0 0 20px #ff4757;
}

.battle-actions {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 20px;
}

.battle-action-btn {
  background: linear-gradient(45deg, #ff4757, #ff6b6b);
  border: none;
  padding: 12px 20px;
  color: white;
  border-radius: 15px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s ease;
  min-width: 100px;
}

.battle-action-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 8px 25px rgba(255, 71, 87, 0.5);
}

.battle-log {
  background: rgba(0, 0, 0, 0.4);
  padding: 15px;
  border-radius: 10px;
  margin: 15px 0;
  min-height: 80px;
  border: 1px solid rgba(255, 71, 87, 0.3);
  text-align: left;
  font-size: 14px;
  overflow-y: auto;
  max-height: 120px;
}

/* Other panels */
.chance-card, .jail-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border-radius: 20px;
  padding: 25px;
  z-index: 2000;
  display: none;
  width: 90%;
  max-width: 400px;
  text-align: center;
  backdrop-filter: blur(15px);
}

.chance-card {
  background: linear-gradient(145deg, rgba(153, 50, 204, 0.95), rgba(139, 0, 139, 0.95));
  border: 3px solid #ffd700;
  box-shadow: 0 0 50px rgba(255, 215, 0, 0.4);
}

.jail-panel {
  background: linear-gradient(145deg, rgba(220, 20, 60, 0.95), rgba(178, 34, 34, 0.95));
  border: 3px solid #fff;
  box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
  color: #fff;
}

.jail-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
  margin-top: 15px;
  flex-wrap: wrap;
}

.jail-btn {
  background: linear-gradient(45deg, #ffa500, #ff8c00);
  border: none;
  padding: 10px 15px;
  color: white;
  border-radius: 10px;
  cursor: pointer;
  font-size: clamp(12px, 3vw, 14px);
  transition: all 0.3s ease;
  font-weight: bold;
  min-width: 100px;
}

.jail-btn:hover {
  transform: scale(1.05);
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .container {
    padding: 5px;
  }
  
  .dice-section {
    padding: 15px;
    gap: 12px;
  }
  
  .player-info {
    min-width: 110px;
    padding: 12px;
  }
  
  .board {
    margin-bottom: 20px;
  }
  
  .upgrade-options {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
  
  .jail-buttons {
    flex-direction: column;
    gap: 8px;
  }
  
  .battle-field {
    flex-direction: column;
    gap: 15px;
  }
  
  .battle-actions {
    flex-wrap: wrap;
    gap: 10px;
  }
}

@media (max-width: 480px) {
  .dice-section {
    gap: 8px;
  }
  
  .player-info {
    min-width: 90px;
    padding: 10px;
  }
  
  .upgrade-options {
    grid-template-columns: 1fr;
  }
  
  .dice-area {
    gap: 10px;
  }
}
</style>
</head>
<body>

<div class="container">
  <h1>üêâ KRYPTOMON MONOPOLY üêâ</h1>
  
  <!-- Menu Screen -->
  <div id="menu" class="menu">
    <button onclick="startGame()">üéÆ Start Game</button>
    <button onclick="showRules()">üìñ How to Play</button>
    <button onclick="exitGame()">‚ùå Exit</button>
  </div>

  <!-- Game Screen -->
  <div id="game" class="game-container">
    <div class="game-layout">
      <!-- Game Board -->
      <div class="board-container">
        <div id="board" class="board"></div>
        
        <!-- Dice Section with Player Info -->
        <div class="dice-section">
          <!-- Left Player Info -->
          <div id="playerInfo" class="player-info">
            <div class="player-avatar player"></div>
            <div class="player-name">üë§ YOU</div>
            <div class="player-money">üí∞ $<span id="playerMoney">1500</span></div>
            <div class="player-properties">Props: <span id="playerProps">0</span></div>
          </div>
          
          <!-- Dice Area -->
          <div class="dice-area">
            <div class="dice-container">
              <div id="dice1" class="dice">1</div>
              <div id="dice2" class="dice">1</div>
            </div>
            <button id="rollBtn" class="roll-btn" onclick="rollDice()">üé≤ ROLL</button>
          </div>
          
          <!-- Right Player Info -->
          <div id="cpuInfo" class="player-info">
            <div class="player-avatar cpu"></div>
            <div class="player-name">ü§ñ CPU</div>
            <div class="player-money">üí∞ $<span id="cpuMoney">1500</span></div>
            <div class="player-properties">Props: <span id="cpuProps">0</span></div>
          </div>
        </div>

        <div id="gameInfo" class="game-info">Your Turn - Roll the Dice!</div>
      </div>
    </div>

    <button class="back-btn" onclick="backToMenu()">‚Üê Back to Menu</button>
  </div>

  <!-- Purchase Panel -->
  <div id="purchasePanel" class="purchase-panel">
    <button class="close-btn" onclick="closePurchasePanel()">‚úï</button>
    <div class="purchase-title">Property Options</div>
    <div class="property-details">
      <p><strong>Property:</strong> <span id="propertyName">-</span></p>
      <p><strong>Price:</strong> $<span id="propertyPrice">0</span></p>
      <p><strong>Current Rent:</strong> $<span id="currentRentDisplay">0</span></p>
    </div>
    <div class="upgrade-options" id="upgradeOptions">
      <button class="upgrade-btn" id="buyBtn" onclick="buyProperty()">Buy Property<br>$<span id="buyPrice">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(1)">Level 1 üè†<br>$50<br>Rent: $<span id="rent1">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(2)">Level 2 üè†üè†<br>$100<br>Rent: $<span id="rent2">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(3)">Level 3 üè†üè†üè†<br>$150<br>Rent: $<span id="rent3">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(4)">Level 4 üè†üè†üè†üè†<br>$200<br>Rent: $<span id="rent4">0</span></button>
      <button class="upgrade-btn hotel-btn" onclick="buildHotel()">Hotel üè®<br>$300<br>Rent: $<span id="rentHotel">0</span></button>
      <button class="upgrade-btn battle-btn" id="battleBtn" onclick="startBattle()" style="display: none;">‚öîÔ∏è Battle for Property!</button>
    </div>
    <button class="skip-btn" onclick="skipPurchase()">Skip</button>
  </div>

  <!-- Battle Arena -->
  <div id="battleArena" class="battle-arena">
    <div class="battle-title">‚öîÔ∏è KRYPTOMON BATTLE ‚öîÔ∏è</div>
    
    <div class="battle-field">
      <div class="battle-player">
        <div class="battle-avatar player" id="playerBattleAvatar"></div>
        <div class="hp-bar">
          <div class="hp-fill" id="playerHpBar" style="width: 100%;"></div>
        </div>
        <div class="hp-text"><span id="playerBattleHp">100</span>/100 HP</div>
        <div style="color: #00f5ff; font-weight: bold;">YOU</div>
      </div>
      
      <div class="battle-vs">VS</div>
      
      <div class="battle-player">
        <div class="battle-avatar cpu" id="cpuBattleAvatar"></div>
        <div class="hp-bar">
          <div class="hp-fill" id="cpuHpBar" style="width: 100%;"></div>
        </div>
        <div class="hp-text"><span id="cpuBattleHp">100</span>/100 HP</div>
        <div style="color: #2ed573; font-weight: bold;">CPU</div>
      </div>
    </div>
    
    <div class="battle-log" id="battleLog">
      Battle begins! Choose your action!
    </div>
    
    <div class="battle-actions" id="battleActions">
      <button class="battle-action-btn" onclick="battleAction('attack')">üó°Ô∏è Attack</button>
      <button class="battle-action-btn" onclick="battleAction('defend')">üõ°Ô∏è Defend</button>
      <button class="battle-action-btn" onclick="battleAction('magic')">‚ú® Magic</button>
    </div>
  </div>

  <!-- Chance Card -->
  <div id="chanceCard" class="chance-card">
    <h2>üé≤ CHANCE üé≤</h2>
    <div id="chanceText"></div>
    <button class="jail-btn" onclick="closeChanceCard()" style="margin-top: 15px;">OK</button>
  </div>

  <!-- Jail Panel -->
  <div id="jailPanel" class="jail-panel">
    <h2>üîí JAIL üîí</h2>
    <div id="jailText">You are in jail!</div>
    <div class="jail-buttons">
      <button class="jail-btn" onclick="payJailFine()">Pay $200 Fine</button>
      <button class="jail-btn" onclick="tryJailRoll()">Try Double Roll</button>
    </div>
  </div>

  <!-- Message Box -->
  <div id="messageBox" class="message-box"></div>
</div>

<script>
// Game State
let gameState = {
  currentPlayer: 0,
  players: [
    { 
      name: 'You', 
      money: 1500, 
      position: 0, 
      properties: {}, 
      bankrupt: false, 
      inJail: false, 
      jailTurns: 0,
      jailFreeCard: false,
      hp: 100
    },
    { 
      name: 'CPU', 
      money: 1500, 
      position: 0, 
      properties: {}, 
      bankrupt: false, 
      inJail: false, 
      jailTurns: 0,
      jailFreeCard: false,
      hp: 100
    }
  ],
  gameStarted: false,
  canRoll: true,
  lastRoll: [0, 0],
  waitingForPlayer: false,
  currentPropertyIndex: -1,
  battleInProgress: false
};

// Fixed board layout with proper positioning
const boardPositions = [
  // Bottom row (0-4)
  { name: 'START', type: 'start', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Aelum Valley', type: 'property', price: 100, baseRent: 20, element: 'earth' },
  { name: 'CHANCE', type: 'chance', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Sha Mountains', type: 'property', price: 120, baseRent: 25, element: 'earth' },
  { name: 'JAIL', type: 'jail', price: 0, baseRent: 0, element: 'neutral' },
  
  // Right column (5-7)
  { name: 'Oura Canyon', type: 'property', price: 140, baseRent: 30, element: 'fire' },
  { name: 'AIRPORT', type: 'airport', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Ukko Desert', type: 'property', price: 160, baseRent: 35, element: 'fire' },
  
  // Top row (8-11)
  { name: 'FREE PARKING', type: 'special', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Haamu Peaks', type: 'property', price: 180, baseRent: 40, element: 'ice' },
  { name: 'TAX', type: 'tax', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Bosco Valley', type: 'property', price: 200, baseRent: 45, element: 'water' },
  
  // Left column (12-15)
  { name: 'Airport', type: 'property', price: 220, baseRent: 50, element: 'air' },
  { name: 'Cryonia', type: 'property', price: 240, baseRent: 55, element: 'crystal' },
  { name: 'Sky Temple', type: 'property', price: 260, baseRent: 60, element: 'air' },
  { name: 'Thunder Peak', type: 'property', price: 280, baseRent: 65, element: 'thunder' }
];

// Property sets for winning condition (3 properties each)
const propertySets = [
  [1, 3], // Earth properties (Aelum Valley, Sha Mountains) - need 1 more
  [5, 7], // Fire properties (Oura Canyon, Ukko Desert) - need 1 more  
  [9, 11], // Ice/Water properties (Haamu Peaks, Bosco Valley) - need 1 more
  [12, 13, 14], // Air properties (Airport, Cryonia, Sky Temple)
  [15] // Thunder (just one)
];

// Reduced chance cards
const chanceCards = [
  { text: "Get out of jail free! Keep this card.", effect: "jailFree" },
  { text: "Collect $100 from bank!", effect: "collect100" },
  { text: "Go to jail! Do not pass START.", effect: "goToJail" },
  { text: "Advance to START! Collect $100.", effect: "goToStart" },
  { text: "Pay $25 tax!", effect: "pay25" },
  { text: "Collect $50 bonus!", effect: "collect50" }
];

// Battle system
const battleActions = {
  attack: { name: 'Attack', minDamage: 15, maxDamage: 35 },
  defend: { name: 'Defend', minDamage: 5, maxDamage: 15, shield: true },
  magic: { name: 'Magic', minDamage: 20, maxDamage: 45, magical: true }
};

function initGame() {
  createBoard();
  updateDisplay();
  updateGameInfo();
}

function createBoard() {
  const board = document.getElementById('board');
  board.innerHTML = '';
  
  // 5x5 grid (25 cells total, 16 used for board)
  for (let i = 0; i < 25; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    
    const boardIndex = getBoardIndex(i);
    
    if (boardIndex !== -1) {
      const position = boardPositions[boardIndex];
      
      // Add type classes
      if (position.type === 'start') cell.classList.add('start');
      else if (position.type === 'jail') cell.classList.add('jail');
      else if (position.type === 'chance') cell.classList.add('chance');
      else if (position.type === 'tax') cell.classList.add('tax');
      else if (position.type === 'airport') cell.classList.add('airport');
      
      // Add element classes for properties
      if (position.element && position.element !== 'neutral') {
        cell.classList.add(position.element);
      }
      
      cell.innerHTML = `<div class="cell-name">${position.name}</div>`;
      cell.dataset.position = boardIndex;
      
      if (position.type === 'property') {
        const rentDiv = document.createElement('div');
        rentDiv.className = 'cell-rent';
        rentDiv.textContent = `$${position.baseRent}`;
        cell.appendChild(rentDiv);
      }
    } else {
      cell.classList.add('empty');
    }
    
    board.appendChild(cell);
  }
  
  updateTokens();
  updatePropertyDisplay();
}

function getBoardIndex(gridIndex) {
  // Perfect 5x5 square mapping - FIXED!
  const gridToBoardMap = {
    // Bottom row (0-4)
    20: 0, 21: 1, 22: 2, 23: 3, 24: 4,
    // Right column (5-7) 
    19: 5, 14: 6, 9: 7,
    // Top row (8-11)
    4: 8, 3: 9, 2: 10, 1: 11,
    // Left column (12-15)
    0: 12, 5: 13, 10: 14, 15: 15
  };
  
  return gridToBoardMap[gridIndex] || -1;
}

function updateTokens() {
  document.querySelectorAll('.player-token').forEach(token => token.remove());
  
  gameState.players.forEach((player, index) => {
    if (!player.bankrupt) {
      const cell = document.querySelector(`[data-position="${player.position}"]`);
      if (cell) {
        const token = document.createElement('div');
        token.className = `player-token token-${index === 0 ? 'player' : 'cpu'}`;
        cell.appendChild(token);
      }
    }
  });
}

function updatePropertyDisplay() {
  boardPositions.forEach((position, index) => {
    if (position.type === 'property') {
      const cell = document.querySelector(`[data-position="${index}"]`);
      if (cell) {
        // Remove old displays
        const oldOwner = cell.querySelector('.owner-tag');
        const oldBuilding = cell.querySelector('.cell-building');
        const oldRent = cell.querySelector('.cell-rent');
        
        if (oldOwner) oldOwner.remove();
        if (oldBuilding) oldBuilding.remove();
        if (oldRent) oldRent.remove();
        
        const propertyData = getPropertyData(index);
        
        // Add rent display
        const rentDiv = document.createElement('div');
        rentDiv.className = 'cell-rent';
        rentDiv.textContent = `$${calculateRent(index)}`;
        cell.appendChild(rentDiv);
        
        if (propertyData.owner !== undefined) {
          // Add owner tag
          const ownerTag = document.createElement('div');
          ownerTag.className = `owner-tag owner-${propertyData.owner === 0 ? 'player' : 'cpu'}`;
          ownerTag.textContent = propertyData.owner === 0 ? 'P' : 'C';
          cell.appendChild(ownerTag);
          
          // Add building display
          if (propertyData.level > 0) {
            const building = document.createElement('div');
            building.className = 'cell-building';
            if (propertyData.hotel) {
              building.textContent = 'üè®';
            } else {
              building.textContent = 'üè†'.repeat(propertyData.level);
            }
            cell.appendChild(building);
          }
        }
      }
    }
  });
}

function updateDisplay() {
  // Update player money and properties
  document.getElementById('playerMoney').textContent = gameState.players[0].money;
  document.getElementById('cpuMoney').textContent = gameState.players[1].money;
  
  // Count properties
  const playerProps = Object.keys(gameState.players[0].properties).length;
  const cpuProps = Object.keys(gameState.players[1].properties).length;
  
  document.getElementById('playerProps').textContent = playerProps;
  document.getElementById('cpuProps').textContent = cpuProps;
  
  // Update active player
  const playerInfo = document.getElementById('playerInfo');
  const cpuInfo = document.getElementById('cpuInfo');
  
  if (gameState.currentPlayer === 0) {
    playerInfo.classList.add('active');
    cpuInfo.classList.remove('active');
    document.getElementById('rollBtn').disabled = false;
  } else {
    cpuInfo.classList.add('active');
    playerInfo.classList.remove('active');
    document.getElementById('rollBtn').disabled = true;
  }
  
  updatePropertyDisplay();
  checkWinCondition();
}

function updateGameInfo(message = '') {
  const gameInfo = document.getElementById('gameInfo');
  if (message) {
    gameInfo.textContent = message;
  } else {
    const currentPlayerName = gameState.players[gameState.currentPlayer].name;
    gameInfo.textContent = `${currentPlayerName}'s Turn`;
  }
}

function getPropertyData(positionIndex) {
  for (let i = 0; i < gameState.players.length; i++) {
    if (gameState.players[i].properties[positionIndex]) {
      return gameState.players[i].properties[positionIndex];
    }
  }
  return { owner: undefined, level: 0, hotel: false };
}

function calculateRent(positionIndex) {
  const position = boardPositions[positionIndex];
  const propertyData = getPropertyData(positionIndex);
  
  if (propertyData.owner === undefined) {
    return position.baseRent;
  }
  
  let rent = position.baseRent;
  
  if (propertyData.hotel) {
    rent = position.baseRent * 8; // Hotel multiplier
  } else if (propertyData.level > 0) {
    rent = position.baseRent * (1 + propertyData.level); // Level multiplier
  }
  
  return rent;
}

// Check win condition - Complete property sets
function checkWinCondition() {
  gameState.players.forEach((player, playerIndex) => {
    if (player.bankrupt) return;
    
    // Check for complete property sets (3 properties in a row)
    const ownedProperties = Object.keys(player.properties).map(Number);
    
    // Check each property set
    for (let set of propertySets) {
      if (set.length >= 3 && set.every(propIndex => ownedProperties.includes(propIndex))) {
        showMessage(`üéâ ${player.name} WINS! Complete property set achieved! üéâ`);
        setTimeout(() => {
          backToMenu();
        }, 3000);
        return;
      }
    }
    
    // Check if opponent is bankrupt
    const opponent = gameState.players[1 - playerIndex];
    if (opponent.bankrupt) {
      showMessage(`üéâ ${player.name} WINS! Opponent went bankrupt! üéâ`);
      setTimeout(() => {
        backToMenu();
      }, 3000);
      return;
    }
  });
}

function startGame() {
  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  gameState.gameStarted = true;
  initGame();
  showMessage('üéÆ Game Started! Roll the dice to begin your adventure!');
}

function backToMenu() {
  document.getElementById('game').style.display = 'none';
  document.getElementById('menu').style.display = 'block';
  resetGame();
}

function resetGame() {
  gameState = {
    currentPlayer: 0,
    players: [
      { 
        name: 'You', 
        money: 1500, 
        position: 0, 
        properties: {}, 
        bankrupt: false, 
        inJail: false, 
        jailTurns: 0,
        jailFreeCard: false,
        hp: 100
      },
      { 
        name: 'CPU', 
        money: 1500, 
        position: 0, 
        properties: {}, 
        bankrupt: false, 
        inJail: false, 
        jailTurns: 0,
        jailFreeCard: false,
        hp: 100
      }
    ],
    gameStarted: false,
    canRoll: true,
    lastRoll: [0, 0],
    waitingForPlayer: false,
    currentPropertyIndex: -1,
    battleInProgress: false
  };
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function showMessage(message) {
  const messageBox = document.getElementById('messageBox');
  messageBox.textContent = message;
  messageBox.style.display = 'block';
  
  setTimeout(() => {
    messageBox.style.display = 'none';
  }, 2500);
}

async function rollDice() {
  if (!gameState.canRoll || gameState.waitingForPlayer || gameState.currentPlayer !== 0) return;
  
  const currentPlayer = gameState.players[gameState.currentPlayer];
  
  if (currentPlayer.inJail) {
    showJailPanel();
    return;
  }
  
  gameState.canRoll = false;
  const dice1 = document.getElementById('dice1');
  const dice2 = document.getElementById('dice2');
  const rollBtn = document.getElementById('rollBtn');
  
  dice1.classList.add('rolling');
  dice2.classList.add('rolling');
  rollBtn.disabled = true;
  
  let d1, d2;
  for (let i = 0; i < 10; i++) {
    d1 = Math.floor(Math.random() * 6) + 1;
    d2 = Math.floor(Math.random() * 6) + 1;
    dice1.textContent = d1;
    dice2.textContent = d2;
    await sleep(100);
  }
  
  gameState.lastRoll = [d1, d2];
  const rollResult = d1 + d2;
  
  dice1.classList.remove('rolling');
  dice2.classList.remove('rolling');
  
  updateGameInfo(`${currentPlayer.name} rolled ${d1} + ${d2} = ${rollResult}`);
  
  await movePlayer(gameState.currentPlayer, rollResult);
  await handleLanding();
  
  if (!gameState.waitingForPlayer) {
    nextTurn();
  }
}

async function movePlayer(playerIndex, steps) {
  const player = gameState.players[playerIndex];
  const startPos = player.position;
  
  for (let i = 0; i < steps; i++) {
    player.position = (player.position + 1) % boardPositions.length;
    updateTokens();
    await sleep(200);
  }
  
  // Check if passed START - reduced to $100
  if (startPos + steps >= boardPositions.length || (startPos > player.position && steps < boardPositions.length)) {
    player.money += 100;
    showMessage(`${player.name} passed START and collected $100!`);
    await sleep(1000);
  }
}

async function handleLanding() {
  const player = gameState.players[gameState.currentPlayer];
  const position = boardPositions[player.position];
  
  updateDisplay();
  
  if (position.type === 'property') {
    await handlePropertyLanding(player, player.position, position);
  } else if (position.type === 'chance') {
    await handleChanceLanding();
  } else if (position.type === 'tax') {
    player.money -= 100;
    showMessage(`${player.name} paid $100 tax!`);
    await sleep(1500);
  } else if (position.type === 'airport') {
    if (gameState.currentPlayer === 0) {
      showMessage("‚úàÔ∏è Welcome to the Airport! Choose your destination for next turn!");
      await sleep(1500);
    }
  }
  
  updateDisplay();
}

async function handlePropertyLanding(player, positionIndex, position) {
  const propertyData = getPropertyData(positionIndex);
  
  if (propertyData.owner === undefined) {
    // Property available for purchase
    if (gameState.currentPlayer === 0) {
      // Human player
      gameState.waitingForPlayer = true;
      showPurchasePanel(positionIndex, position, true);
    } else {
      // CPU player - smart decision making
      await sleep(1000);
      
      // CPU intelligence: buy if affordable and strategic
      const shouldBuy = player.money >= position.price * 1.3 && Math.random() > 0.3;
      
      if (shouldBuy) {
        buyPropertyCPU(positionIndex);
        showMessage(`ü§ñ CPU bought ${position.name} for $${position.price}!`);
        await sleep(2000);
      }
    }
  } else if (propertyData.owner !== gameState.currentPlayer) {
    // Pay rent or battle
    const rent = calculateRent(positionIndex);
    
    if (gameState.currentPlayer === 0) {
      // Human player on opponent property
      gameState.waitingForPlayer = true;
      gameState.currentPropertyIndex = positionIndex;
      showPurchasePanel(positionIndex, position, false, true);
    } else {
      // CPU pays rent or battles
      if (player.money >= rent) {
        player.money -= rent;
        gameState.players[propertyData.owner].money += rent;
        showMessage(`ü§ñ CPU paid $${rent} rent!`);
        await sleep(2000);
        
        // CPU might battle if strategic
        if (Math.random() > 0.7 && player.money > 500) {
          showMessage("ü§ñ CPU challenges you to battle!");
          await sleep(1500);
          gameState.battleInProgress = true;
          gameState.currentPropertyIndex = positionIndex;
          startBattleCPU();
        }
      } else {
        handleBankruptcy(gameState.currentPlayer, rent);
      }
    }
  } else {
    // Own property - upgrade opportunity
    if (gameState.currentPlayer === 0) {
      gameState.waitingForPlayer = true;
      showPurchasePanel(positionIndex, position, false);
    } else {
      // CPU upgrade logic
      await sleep(1000);
      const currentData = gameState.players[gameState.currentPlayer].properties[positionIndex];
      
      if (currentData && !currentData.hotel && player.money >= 200) {
        if (currentData.level < 4 && Math.random() > 0.5) {
          const upgradeCost = 50 + (currentData.level * 25);
          if (player.money >= upgradeCost) {
            upgradePropertyCPU(positionIndex, currentData.level + 1);
            showMessage(`ü§ñ CPU upgraded ${position.name} to Level ${currentData.level + 1}!`);
            await sleep(1500);
          }
        } else if (currentData.level === 4 && Math.random() > 0.6) {
          if (player.money >= 300) {
            buildHotelCPU(positionIndex);
            showMessage(`ü§ñ CPU built a hotel at ${position.name}!`);
            await sleep(1500);
          }
        }
      }
    }
  }
}

async function handleChanceLanding() {
  const card = chanceCards[Math.floor(Math.random() * chanceCards.length)];
  const player = gameState.players[gameState.currentPlayer];
  
  document.getElementById('chanceText').textContent = card.text;
  document.getElementById('chanceCard').style.display = 'block';
  
  // Wait for user to close card
  await new Promise(resolve => {
    window.closeChanceCard = () => {
      document.getElementById('chanceCard').style.display = 'none';
      resolve();
    };
  });
  
  // Apply effect
  switch (card.effect) {
    case 'jailFree':
      player.jailFreeCard = true;
      break;
    case 'collect100':
      player.money += 100;
      break;
    case 'goToJail':
      player.inJail = true;
      player.position = 4; // Jail position
      player.jailTurns = 0;
      updateTokens();
      break;
    case 'goToStart':
      player.position = 0;
      player.money += 100;
      updateTokens();
      break;
    case 'pay25':
      player.money -= 25;
      break;
    case 'collect50':
      player.money += 50;
      break;
  }
  
  updateDisplay();
}

function showPurchasePanel(positionIndex, position, canBuy = false, canBattle = false) {
  gameState.currentPropertyIndex = positionIndex;
  
  document.getElementById('propertyName').textContent = position.name;
  document.getElementById('propertyPrice').textContent = position.price;
  document.getElementById('currentRentDisplay').textContent = calculateRent(positionIndex);
  
  const propertyData = getPropertyData(positionIndex);
  const isOwned = propertyData.owner !== undefined;
  const isOwnedByPlayer = propertyData.owner === 0;
  const isOwnedByOpponent = propertyData.owner === 1;
  
  // Show/hide buy button
  const buyBtn = document.getElementById('buyBtn');
  if (canBuy && !isOwned) {
    buyBtn.style.display = 'block';
    buyBtn.disabled = gameState.players[0].money < position.price;
    document.getElementById('buyPrice').textContent = position.price;
  } else {
    buyBtn.style.display = 'none';
  }
  
  // Show/hide upgrade buttons
  const upgradeButtons = document.querySelectorAll('.upgrade-btn:not(#buyBtn):not(.battle-btn)');
  upgradeButtons.forEach((btn, index) => {
    if (isOwnedByPlayer) {
      btn.style.display = 'block';
      const level = index + 1;
      const cost = level <= 4 ? 50 + ((level - 1) * 25) : 300;
      
      if (level <= 4) {
        btn.disabled = gameState.players[0].money < cost || 
                      (propertyData.level >= level) ||
                      propertyData.hotel;
        document.getElementById(`rent${level}`).textContent = 
          position.baseRent * (1 + level);
      } else {
        // Hotel button
        btn.disabled = gameState.players[0].money < 300 || 
                      propertyData.level < 4 || 
                      propertyData.hotel;
        document.getElementById('rentHotel').textContent = 
          position.baseRent * 8;
      }
    } else {
      btn.style.display = 'none';
    }
  });
  
  // Show/hide battle button
  const battleBtn = document.getElementById('battleBtn');
  if (canBattle && isOwnedByOpponent) {
    battleBtn.style.display = 'block';
  } else {
    battleBtn.style.display = 'none';
  }
  
  document.getElementById('purchasePanel').style.display = 'block';
}

function closePurchasePanel() {
  document.getElementById('purchasePanel').style.display = 'none';
  gameState.waitingForPlayer = false;
  gameState.currentPropertyIndex = -1;
  
  if (!gameState.battleInProgress) {
    nextTurn();
  }
}

function skipPurchase() {
  closePurchasePanel();
}

function buyProperty() {
  const positionIndex = gameState.currentPropertyIndex;
  const position = boardPositions[positionIndex];
  const player = gameState.players[0];
  
  if (player.money >= position.price) {
    player.money -= position.price;
    player.properties[positionIndex] = {
      owner: 0,
      level: 0,
      hotel: false
    };
    
    showMessage(`‚úÖ You bought ${position.name} for $${position.price}!`);
    updateDisplay();
    closePurchasePanel();
  }
}

function buyPropertyCPU(positionIndex) {
  const position = boardPositions[positionIndex];
  const player = gameState.players[1];
  
  player.money -= position.price;
  player.properties[positionIndex] = {
    owner: 1,
    level: 0,
    hotel: false
  };
  
  updateDisplay();
}

function upgradeProperty(level) {
  const positionIndex = gameState.currentPropertyIndex;
  const player = gameState.players[0];
  const cost = 50 + ((level - 1) * 25);
  
  if (player.money >= cost) {
    player.money -= cost;
    player.properties[positionIndex].level = level;
    
    showMessage(`üè† Property upgraded to Level ${level}!`);
    updateDisplay();
    showPurchasePanel(positionIndex, boardPositions[positionIndex], false);
  }
}

function upgradePropertyCPU(positionIndex, level) {
  const player = gameState.players[1];
  const cost = 50 + ((level - 1) * 25);
  
  player.money -= cost;
  player.properties[positionIndex].level = level;
  updateDisplay();
}

function buildHotel() {
  const positionIndex = gameState.currentPropertyIndex;
  const player = gameState.players[0];
  
  if (player.money >= 300) {
    player.money -= 300;
    player.properties[positionIndex].hotel = true;
    player.properties[positionIndex].level = 0;
    
    showMessage(`üè® Hotel built!`);
    updateDisplay();
    closePurchasePanel();
  }
}

function buildHotelCPU(positionIndex) {
  const player = gameState.players[1];
  
  player.money -= 300;
  player.properties[positionIndex].hotel = true;
  player.properties[positionIndex].level = 0;
  updateDisplay();
}

// Jail System - FIXED!
function showJailPanel() {
  const player = gameState.players[gameState.currentPlayer];
  
  document.getElementById('jailText').textContent = 
    `You are in jail! Turn ${player.jailTurns + 1}/3`;
  document.getElementById('jailPanel').style.display = 'block';
}

function payJailFine() {
  const player = gameState.players[gameState.currentPlayer];
  
  if (player.money >= 200) {
    player.money -= 200;
    player.inJail = false;
    player.jailTurns = 0;
    
    showMessage("üí∞ You paid the fine and are now free!");
    updateDisplay();
    document.getElementById('jailPanel').style.display = 'none';
    
    // Continue with normal turn
    gameState.canRoll = true;
  } else {
    showMessage("‚ùå Not enough money to pay fine!");
  }
}

async function tryJailRoll() {
  document.getElementById('jailPanel').style.display = 'none';
  
  const player = gameState.players[gameState.currentPlayer];
  const dice1 = document.getElementById('dice1');
  const dice2 = document.getElementById('dice2');
  
  dice1.classList.add('rolling');
  dice2.classList.add('rolling');
  
  let d1, d2;
  for (let i = 0; i < 8; i++) {
    d1 = Math.floor(Math.random() * 6) + 1;
    d2 = Math.floor(Math.random() * 6) + 1;
    dice1.textContent = d1;
    dice2.textContent = d2;
    await sleep(100);
  }
  
  dice1.classList.remove('rolling');
  dice2.classList.remove('rolling');
  
  // Check for EXACT doubles (same numbers)
  if (d1 === d2) {
    player.inJail = false;
    player.jailTurns = 0;
    showMessage(`üé≤ Doubles! ${d1}-${d1} You're free!`);
    
    await sleep(1500);
    await movePlayer(gameState.currentPlayer, d1 + d2);
    await handleLanding();
    
    if (!gameState.waitingForPlayer) {
      nextTurn();
    }
  } else {
    player.jailTurns++;
    showMessage(`‚ùå No doubles! ${d1}-${d2} Still in jail!`);
    
    if (player.jailTurns >= 3) {
      // Force payment after 3 failed attempts
      if (player.money >= 200) {
        player.money -= 200;
        player.inJail = false;
        player.jailTurns = 0;
        showMessage("‚öñÔ∏è Forced to pay fine after 3 attempts!");
        
        await sleep(1500);
        await movePlayer(gameState.currentPlayer, d1 + d2);
        await handleLanding();
        
        if (!gameState.waitingForPlayer) {
          nextTurn();
        }
      } else {
        // Bankruptcy
        handleBankruptcy(gameState.currentPlayer, 200);
      }
    } else {
      nextTurn();
    }
  }
}

// Battle System - FIXED!
function startBattle() {
  const positionIndex = gameState.currentPropertyIndex;
  const position = boardPositions[positionIndex];
  
  gameState.battleInProgress = true;
  gameState.players[0].hp = 100;
  gameState.players[1].hp = 100;
  
  document.getElementById('playerBattleHp').textContent = 100;
  document.getElementById('cpuBattleHp').textContent = 100;
  document.getElementById('playerHpBar').style.width = '100%';
  document.getElementById('cpuHpBar').style.width = '100%';
  document.getElementById('battleLog').textContent = 
    `Battle for ${position.name}! Choose your action!`;
  
  document.getElementById('purchasePanel').style.display = 'none';
  document.getElementById('battleArena').style.display = 'block';
}

async function battleAction(action) {
  if (!gameState.battleInProgress) return;
  
  const battleData = battleActions[action];
  if (!battleData) return;
  
  const playerDamage = Math.floor(Math.random() * (battleData.maxDamage - battleData.minDamage + 1)) + battleData.minDamage;
  
  // CPU action
  const cpuActions = ['attack', 'defend', 'magic'];
  const cpuAction = cpuActions[Math.floor(Math.random() * cpuActions.length)];
  const cpuBattleData = battleActions[cpuAction];
  const cpuDamage = Math.floor(Math.random() * (cpuBattleData.maxDamage - cpuBattleData.minDamage + 1)) + cpuBattleData.minDamage;
  
  // Apply damage
  gameState.players[1].hp -= playerDamage;
  gameState.players[0].hp -= cpuDamage;
  
  // Animations
  document.getElementById('playerBattleAvatar').classList.add('attacking');
  document.getElementById('cpuBattleAvatar').classList.add('defending');
  
  setTimeout(() => {
    document.getElementById('playerBattleAvatar').classList.remove('attacking');
    document.getElementById('cpuBattleAvatar').classList.remove('defending');
  }, 800);
  
  // Update display
  const playerHp = Math.max(0, gameState.players[0].hp);
  const cpuHp = Math.max(0, gameState.players[1].hp);
  
  document.getElementById('playerBattleHp').textContent = playerHp;
  document.getElementById('cpuBattleHp').textContent = cpuHp;
  document.getElementById('playerHpBar').style.width = `${playerHp}%`;
  document.getElementById('cpuHpBar').style.width = `${cpuHp}%`;
  
  // Battle log
  const log = document.getElementById('battleLog');
  log.innerHTML += `<br>You used ${action} (${playerDamage} damage)`;
  log.innerHTML += `<br>CPU used ${cpuAction} (${cpuDamage} damage)`;
  log.scrollTop = log.scrollHeight;
  
  // Check battle end
  if (playerHp <= 0 || cpuHp <= 0) {
    await sleep(1000);
    endBattle(playerHp > cpuHp);
  }
}

function endBattle(playerWon) {
  gameState.battleInProgress = false;
  const positionIndex = gameState.currentPropertyIndex;
  const position = boardPositions[positionIndex];
  
  if (playerWon) {
    // Player wins - can buy opponent property at 2x price
    const buyPrice = position.price * 2;
    
    if (gameState.players[0].money >= buyPrice) {
      gameState.players[0].money -= buyPrice;
      gameState.players[1].money += buyPrice;
      
      // Transfer property
      delete gameState.players[1].properties[positionIndex];
      gameState.players[0].properties[positionIndex] = {
        owner: 0,
        level: 0,
        hotel: false
      };
      
      showMessage(`‚öîÔ∏è Victory! You conquered ${position.name}!`);
    } else {
      showMessage("‚öîÔ∏è You won but don't have enough money to buy the property!");
    }
  } else {
    // CPU wins
    const rent = calculateRent(positionIndex) * 2; // Double rent as penalty
    
    if (gameState.players[0].money >= rent) {
      gameState.players[0].money -= rent;
      gameState.players[1].money += rent;
      showMessage(`üíÄ Defeat! You paid double rent: $${rent}`);
    } else {
      handleBankruptcy(0, rent);
    }
  }
  
  document.getElementById('battleArena').style.display = 'none';
  updateDisplay();
  gameState.currentPropertyIndex = -1;
  nextTurn();
}

function startBattleCPU() {
  // Auto-battle for CPU
  setTimeout(() => {
    const playerHp = Math.floor(Math.random() * 40) + 60; // 60-100
    const cpuHp = Math.floor(Math.random() * 40) + 60; // 60-100
    
    const playerWon = playerHp > cpuHp;
    
    if (!playerWon) {
      // CPU wins - takes player property
      const positionIndex = gameState.currentPropertyIndex;
      const buyPrice = boardPositions[positionIndex].price * 2;
      
      gameState.players[1].money -= buyPrice;
      gameState.players[0].money += buyPrice;
      
      delete gameState.players[0].properties[positionIndex];
      gameState.players[1].properties[positionIndex] = {
        owner: 1,
        level: 0,
        hotel: false
      };
      
      showMessage(`üíÄ CPU won the battle and took your property!`);
    } else {
      showMessage(`‚öîÔ∏è You won the battle against CPU!`);
    }
    
    gameState.battleInProgress = false;
    updateDisplay();
    nextTurn();
  }, 2000);
}

function handleBankruptcy(playerIndex, debt) {
  const player = gameState.players[playerIndex];
  
  if (playerIndex === 0) {
    // Human player bankruptcy - try to sell properties first
    showSellPanel(debt);
  } else {
    // CPU bankruptcy
    player.bankrupt = true;
    showMessage(`ü§ñ CPU went bankrupt!`);
    checkWinCondition();
  }
}

function showSellPanel(neededAmount) {
  document.getElementById('neededMoney').textContent = neededAmount;
  document.getElementById('currentMoney').textContent = gameState.players[0].money;
  document.getElementById('missingMoney').textContent = 
    Math.max(0, neededAmount - gameState.players[0].money);
  
  const propertyList = document.getElementById('propertyList');
  propertyList.innerHTML = '';
  
  Object.keys(gameState.players[0].properties).forEach(propIndex => {
    const position = boardPositions[propIndex];
    const sellPrice = Math.floor(position.price * 0.8); // 80% of original price
    
    const item = document.createElement('div');
    item.className = 'property-sell-item';
    item.innerHTML = `
      <span>${position.name} - $${sellPrice}</span>
      <button class="sell-property-btn" onclick="sellProperty(${propIndex})">Sell</button>
    `;
    propertyList.appendChild(item);
  });
  
  document.getElementById('sellPanel').style.display = 'block';
}

function sellProperty(propIndex) {
  const position = boardPositions[propIndex];
  const sellPrice = Math.floor(position.price * 0.8);
  
  gameState.players[0].money += sellPrice;
  delete gameState.players[0].properties[propIndex];
  
  showMessage(`üí∏ Sold ${position.name} for $${sellPrice}`);
  updateDisplay();
  
  // Check if player has enough money now
  const neededAmount = parseInt(document.getElementById('neededMoney').textContent);
  if (gameState.players[0].money >= neededAmount) {
    document.getElementById('sellPanel').style.display = 'none';
    
    // Pay the debt
    gameState.players[0].money -= neededAmount;
    const opponent = gameState.players[1];
    opponent.money += neededAmount;
    
    showMessage(`‚úÖ Debt paid! Continuing game...`);
    updateDisplay();
    nextTurn();
  } else {
    // Update the sell panel
    showSellPanel(neededAmount);
  }
}

function declareBankruptcy() {
  gameState.players[0].bankrupt = true;
  document.getElementById('sellPanel').style.display = 'none';
  showMessage(`üíÄ You declared bankruptcy! Game Over!`);
  
  setTimeout(() => {
    backToMenu();
  }, 3000);
}

async function nextTurn() {
  if (gameState.battleInProgress || gameState.waitingForPlayer) return;
  
  gameState.currentPlayer = 1 - gameState.currentPlayer;
  gameState.canRoll = true;
  updateDisplay();
  
  // CPU turn
  if (gameState.currentPlayer === 1) {
    await sleep(1500);
    await cpuTurn();
  }
}

async function cpuTurn() {
  const cpu = gameState.players[1];
  
  if (cpu.inJail) {
    // CPU jail logic
    if (cpu.jailFreeCard) {
      cpu.jailFreeCard = false;
      cpu.inJail = false;
      cpu.jailTurns = 0;
      showMessage("ü§ñ CPU used Get Out of Jail Free card!");
      await sleep(1500);
    } else if (cpu.money >= 200 && Math.random() > 0.4) {
      cpu.money -= 200;
      cpu.inJail = false;
      cpu.jailTurns = 0;
      showMessage("ü§ñ CPU paid $200 to get out of jail!");
      await sleep(1500);
    } else {
      // Try doubles
      await tryJailRollCPU();
      return;
    }
  }
  
  // Regular turn
  gameState.canRoll = false;
  updateGameInfo("ü§ñ CPU is thinking...");
  
  await sleep(1000);
  
  const dice1 = document.getElementById('dice1');
  const dice2 = document.getElementById('dice2');
  
  dice1.classList.add('rolling');
  dice2.classList.add('rolling');
  
  let d1, d2;
  for (let i = 0; i < 8; i++) {
    d1 = Math.floor(Math.random() * 6) + 1;
    d2 = Math.floor(Math.random() * 6) + 1;
    dice1.textContent = d1;
    dice2.textContent = d2;
    await sleep(100);
  }
  
  dice1.classList.remove('rolling');
  dice2.classList.remove('rolling');
  
  const rollResult = d1 + d2;
  updateGameInfo(`ü§ñ CPU rolled ${d1} + ${d2} = ${rollResult}`);
  
  await sleep(1000);
  await movePlayer(1, rollResult);
  await handleLanding();
  
  if (!gameState.battleInProgress) {
    nextTurn();
  }
}

async function tryJailRollCPU() {
  const cpu = gameState.players[1];
  
  let d1 = Math.floor(Math.random() * 6) + 1;
  let d2 = Math.floor(Math.random() * 6) + 1;
  
  if (d1 === d2) {
    cpu.inJail = false;
    cpu.jailTurns = 0;
    showMessage(`ü§ñ CPU rolled doubles ${d1}-${d2} and escaped jail!`);
    
    await sleep(1500);
    await movePlayer(1, d1 + d2);
    await handleLanding();
    
    if (!gameState.battleInProgress) {
      nextTurn();
    }
  } else {
    cpu.jailTurns++;
    showMessage(`ü§ñ CPU failed to escape jail: ${d1}-${d2}`);
    
    if (cpu.jailTurns >= 3) {
      if (cpu.money >= 200) {
        cpu.money -= 200;
        cpu.inJail = false;
        cpu.jailTurns = 0;
        showMessage("ü§ñ CPU forced to pay fine after 3 attempts!");
        
        await sleep(1500);
        await movePlayer(1, d1 + d2);
        await handleLanding();
        
        if (!gameState.battleInProgress) {
          nextTurn();
        }
      } else {
        handleBankruptcy(1, 200);
      }
    } else {
      nextTurn();
    }
  }
}

function showRules() {
  showMessage(`üéÆ KRYPTOMON MONOPOLY RULES:
  
‚Ä¢ Roll dice to move around the board
‚Ä¢ Buy properties and upgrade them (4 levels + hotel)
‚Ä¢ Pay rent when landing on opponent properties
‚Ä¢ Battle opponent for their properties!
‚Ä¢ Win by completing a property set (3 in a row)
‚Ä¢ START gives $100, jail costs $200 to escape
‚Ä¢ Use strategy and luck to dominate!`);
}

function exitGame() {
  if (confirm("Are you sure you want to exit?")) {
    window.close();
  }
}
</script>
</body>
</html>
