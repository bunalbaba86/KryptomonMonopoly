<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kryptomon Monopoly - Perfect Battle Edition</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
  color: #fff;
  min-height: 100vh;
  overflow-x: hidden;
}

.container {
  max-width: 100%;
  margin: 0 auto;
  padding: 10px;
}

h1 {
  text-align: center;
  color: #00f5ff;
  font-size: clamp(1.5rem, 5vw, 3rem);
  margin-bottom: 20px;
  text-shadow: 0 0 30px #00f5ff;
  animation: titleGlow 2s ease-in-out infinite alternate;
  font-weight: 900;
}

@keyframes titleGlow {
  from { text-shadow: 0 0 30px #00f5ff; }
  to { text-shadow: 0 0 50px #00f5ff; }
}

/* Menu */
.menu {
  text-align: center;
  padding: 40px 20px;
  background: rgba(26, 26, 46, 0.3);
  border-radius: 30px;
  backdrop-filter: blur(10px);
  border: 2px solid rgba(0, 245, 255, 0.3);
}

.menu button {
  background: linear-gradient(45deg, #00f5ff, #0080ff);
  border: none;
  padding: 15px 30px;
  margin: 10px;
  font-size: 16px;
  color: white;
  border-radius: 50px;
  cursor: pointer;
  transition: all 0.4s ease;
  box-shadow: 0 8px 30px rgba(0, 245, 255, 0.4);
  font-weight: bold;
  min-width: 150px;
}

.menu button:hover {
  transform: translateY(-2px) scale(1.05);
  box-shadow: 0 15px 40px rgba(0, 245, 255, 0.6);
}

/* Game Layout */
.game-container {
  display: none;
}

.game-layout {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  max-width: 100%;
}

/* Game Board */
.board-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.board {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
  gap: 2px;
  width: min(90vw, 500px);
  height: min(90vw, 500px);
  background: linear-gradient(45deg, #0f1419, #1a1a2e);
  border: 4px solid #00f5ff;
  border-radius: 15px;
  padding: 10px;
  box-shadow: 0 0 30px rgba(0, 245, 255, 0.6);
  margin-bottom: 20px;
}

.cell {
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.95), rgba(22, 33, 62, 0.95));
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  align-items: center;
  padding: 4px;
  position: relative;
  border: 1px solid rgba(0, 245, 255, 0.2);
  transition: all 0.3s ease;
}

.cell.empty {
  background: transparent;
  border: none;
}

.cell:not(.empty):hover {
  border-color: #00f5ff;
  box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
}

.cell-name {
  font-size: clamp(7px, 2vw, 10px);
  font-weight: bold;
  text-align: center;
  color: #fff;
  line-height: 1.1;
  margin-bottom: 3px;
  text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
}

.cell-rent {
  background: linear-gradient(45deg, #00f5ff, #0080ff);
  color: #000;
  padding: 1px 4px;
  border-radius: 4px;
  font-size: clamp(6px, 1.5vw, 8px);
  font-weight: bold;
  margin-top: auto;
}

.cell-building {
  font-size: clamp(8px, 2vw, 12px);
  margin-top: 1px;
  text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
}

.owner-tag {
  position: absolute;
  top: 2px;
  right: 2px;
  padding: 1px 3px;
  border-radius: 4px;
  font-size: clamp(6px, 1.5vw, 8px);
  font-weight: bold;
}

.owner-player { background: #ff4757; color: #fff; }
.owner-cpu { background: #2ed573; color: #000; }

.player-token {
  position: absolute;
  width: clamp(20px, 5vw, 25px);
  height: clamp(20px, 5vw, 25px);
  border-radius: 50%;
  border: 2px solid #fff;
  transition: all 0.8s ease;
  z-index: 15;
  background-size: cover;
  background-position: center;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
}

.token-player {
  background-image: url('kryptomon.png');
  bottom: 3px;
  left: 3px;
  border-color: #00f5ff;
}

.token-cpu {
  background-image: url('kryptomon2.png');
  bottom: 3px;
  right: 3px;
  border-color: #2ed573;
}

/* START cell special styling - Fixed! */
.cell.start {
  background: linear-gradient(145deg, #32cd32, #00ff00) !important;
  color: #000 !important;
  border: 3px solid #32cd32 !important;
  box-shadow: 0 0 25px rgba(50, 205, 50, 0.8) !important;
}

.cell.start .cell-name {
  color: #000 !important;
  font-size: clamp(9px, 2.5vw, 13px) !important;
  font-weight: 900 !important;
  text-shadow: 0 0 15px rgba(255, 255, 255, 0.9) !important;
  background: rgba(255, 255, 255, 0.3) !important;
  padding: 2px 4px !important;
  border-radius: 4px !important;
}

.cell.start .player-token {
  border-width: 3px !important;
  box-shadow: 0 0 20px rgba(255, 255, 255, 1) !important;
  z-index: 25 !important;
}

/* Other special cells */
.cell.jail {
  background: linear-gradient(145deg, #dc143c, #b22222);
  color: #fff;
  border-color: #b22222;
}

.cell.tax {
  background: linear-gradient(145deg, #ff69b4, #ff1493);
  color: #fff;
  border-color: #ff1493;
}

.cell.chance {
  background: linear-gradient(145deg, #9932cc, #8b008b);
  color: #fff;
  border-color: #8b008b;
}

.cell.airport {
  background: linear-gradient(145deg, #00ced1, #40e0d0);
  color: #000;
  border-color: #00ced1;
}

/* Property Element Styling */
.cell.fire {
  background: linear-gradient(145deg, #ff4500, #ff6347) !important;
  border-color: #ff4500 !important;
}

.cell.water {
  background: linear-gradient(145deg, #1e90ff, #4169e1) !important;
  border-color: #1e90ff !important;
}

.cell.earth {
  background: linear-gradient(145deg, #8b4513, #a0522d) !important;
  border-color: #8b4513 !important;
}

.cell.air {
  background: linear-gradient(145deg, #87ceeb, #b0e0e6) !important;
  border-color: #87ceeb !important;
}

.cell.ice {
  background: linear-gradient(145deg, #e0ffff, #b0e0e6) !important;
  border-color: #e0ffff !important;
}

.cell.thunder {
  background: linear-gradient(145deg, #ffd700, #ffff00) !important;
  border-color: #ffd700 !important;
}

.cell.dark {
  background: linear-gradient(145deg, #4b0082, #663399) !important;
  border-color: #4b0082 !important;
}

.cell.crystal {
  background: linear-gradient(145deg, #da70d6, #ff69b4) !important;
  border-color: #da70d6 !important;
}

/* Dice Section with Player Info */
.dice-section {
  display: flex;
  gap: 15px;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
  padding: 15px;
  background: rgba(26, 26, 46, 0.3);
  border-radius: 20px;
  backdrop-filter: blur(10px);
  border: 2px solid rgba(0, 245, 255, 0.3);
  width: 100%;
  max-width: 600px;
}

/* Player Info - Left and Right of Dice */
.player-info {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px;
  border-radius: 15px;
  transition: all 0.5s ease;
  min-width: 120px;
  background: rgba(26, 26, 46, 0.5);
  border: 2px solid rgba(0, 245, 255, 0.2);
}

.player-info.active {
  border-color: #00f5ff;
  box-shadow: 0 0 20px rgba(0, 245, 255, 0.5);
  transform: scale(1.05);
}

.player-avatar {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: 3px solid #00f5ff;
  background-size: cover;
  background-position: center;
  margin-bottom: 8px;
  box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
}

.player-avatar.player { background-image: url('character.png'); }
.player-avatar.cpu { background-image: url('character2.png'); }

.player-name {
  font-size: 14px;
  font-weight: bold;
  margin-bottom: 5px;
  color: #00f5ff;
  text-align: center;
}

.player-money {
  font-size: 16px;
  color: #2ed573;
  margin-bottom: 3px;
  font-weight: bold;
  text-align: center;
}

.player-properties {
  font-size: 10px;
  color: #ccc;
  text-align: center;
}

.dice-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.dice-container {
  display: flex;
  gap: 10px;
}

.dice {
  width: clamp(50px, 12vw, 60px);
  height: clamp(50px, 12vw, 60px);
  background: linear-gradient(45deg, #00f5ff, #0080ff);
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(20px, 5vw, 24px);
  font-weight: bold;
  color: white;
  cursor: pointer;
  transition: all 0.4s ease;
  box-shadow: 0 6px 20px rgba(0, 245, 255, 0.4);
  border: 2px solid #fff;
}

.dice:hover {
  transform: scale(1.1);
}

.dice.rolling {
  animation: roll 0.6s ease-in-out;
}

@keyframes roll {
  0% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.2); }
  100% { transform: rotate(360deg) scale(1); }
}

.roll-btn {
  background: linear-gradient(45deg, #ff6b6b, #ff8e53);
  border: none;
  padding: 12px 20px;
  color: white;
  border-radius: 20px;
  font-size: clamp(14px, 3.5vw, 16px);
  cursor: pointer;
  transition: all 0.4s ease;
  box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
  font-weight: bold;
  min-width: 100px;
}

.roll-btn:hover:not(:disabled) {
  transform: translateY(-2px) scale(1.05);
  box-shadow: 0 10px 30px rgba(255, 107, 107, 0.6);
}

.roll-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Purchase Panel */
.purchase-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #00f5ff;
  border-radius: 20px;
  padding: 20px;
  z-index: 2000;
  display: none;
  width: 90%;
  max-width: 500px;
  max-height: 90vh;
  overflow-y: auto;
  backdrop-filter: blur(20px);
  box-shadow: 0 0 50px rgba(0, 245, 255, 0.6);
  text-align: center;
}

.purchase-title {
  font-size: clamp(20px, 5vw, 24px);
  color: #00f5ff;
  margin-bottom: 15px;
  font-weight: bold;
}

.property-details {
  background: rgba(0, 0, 0, 0.4);
  padding: 12px;
  border-radius: 10px;
  margin: 12px 0;
  text-align: left;
  border: 1px solid rgba(0, 245, 255, 0.2);
  font-size: clamp(12px, 3vw, 14px);
}

.upgrade-options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 10px;
  margin: 15px 0;
}

.upgrade-btn {
  background: linear-gradient(45deg, #ffa500, #ff8c00);
  border: none;
  padding: 12px 8px;
  color: white;
  border-radius: 10px;
  cursor: pointer;
  font-size: clamp(10px, 2.5vw, 12px);
  font-weight: bold;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
  min-height: 60px;
}

.upgrade-btn:hover:not(:disabled) {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(255, 165, 0, 0.5);
}

.upgrade-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.hotel-btn {
  background: linear-gradient(45deg, #ff1493, #dc143c);
}

.battle-btn {
  background: linear-gradient(45deg, #8b00ff, #4b0082);
  grid-column: 1 / -1;
  margin-top: 8px;
}

.skip-btn {
  background: linear-gradient(45deg, #666, #888);
  margin-top: 12px;
  padding: 10px 20px;
  font-size: clamp(14px, 3.5vw, 16px);
  border-radius: 15px;
  border: none;
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

/* Airport Selection Panel */
.airport-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #00ced1;
  border-radius: 20px;
  padding: 25px;
  z-index: 2100;
  display: none;
  width: 90%;
  max-width: 400px;
  backdrop-filter: blur(20px);
  box-shadow: 0 0 50px rgba(0, 206, 209, 0.6);
  text-align: center;
}

.airport-title {
  font-size: 22px;
  color: #00ced1;
  margin-bottom: 20px;
  font-weight: bold;
}

.property-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 8px;
  margin: 15px 0;
}

.property-option {
  background: linear-gradient(45deg, #00ced1, #40e0d0);
  color: #000;
  border: none;
  padding: 8px 4px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 10px;
  font-weight: bold;
  transition: all 0.3s ease;
  min-height: 40px;
}

.property-option:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 15px rgba(0, 206, 209, 0.5);
}

/* Sell Properties Panel */
.sell-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #ff4757;
  border-radius: 20px;
  padding: 25px;
  z-index: 2100;
  display: none;
  width: 90%;
  max-width: 500px;
  backdrop-filter: blur(20px);
  box-shadow: 0 0 50px rgba(255, 71, 87, 0.6);
  text-align: center;
}

.sell-title {
  font-size: 20px;
  color: #ff4757;
  margin-bottom: 15px;
  font-weight: bold;
}

.sell-info {
  background: rgba(0, 0, 0, 0.4);
  padding: 12px;
  border-radius: 10px;
  margin: 12px 0;
  text-align: left;
  border: 1px solid rgba(255, 71, 87, 0.3);
  font-size: 14px;
}

.property-list {
  max-height: 200px;
  overflow-y: auto;
  margin: 15px 0;
}

.property-sell-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(0, 0, 0, 0.3);
  padding: 10px;
  margin: 5px 0;
  border-radius: 8px;
  border: 1px solid rgba(255, 71, 87, 0.2);
}

.sell-property-btn {
  background: linear-gradient(45deg, #ff4757, #ff6b6b);
  border: none;
  padding: 6px 12px;
  color: white;
  border-radius: 8px;
  cursor: pointer;
  font-size: 12px;
  font-weight: bold;
}

/* Battle System */
.battle-arena {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #ff4757;
  border-radius: 20px;
  padding: 25px;
  z-index: 2500;
  display: none;
  width: 90%;
  max-width: 600px;
  backdrop-filter: blur(20px);
  box-shadow: 0 0 60px rgba(255, 71, 87, 0.8);
  text-align: center;
}

.battle-title {
  font-size: 24px;
  color: #ff4757;
  margin-bottom: 20px;
  font-weight: bold;
  text-shadow: 0 0 20px #ff4757;
}

.battle-field {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 20px 0;
  gap: 20px;
}

.battle-player {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

.battle-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background-size: cover;
  background-position: center;
  border: 4px solid #00f5ff;
  margin-bottom: 10px;
  transition: all 0.5s ease;
}

.battle-avatar.player { background-image: url('kryptomon.png'); }
.battle-avatar.cpu { background-image: url('kryptomon2.png'); }

.battle-avatar.attacking {
  animation: attack 0.8s ease-in-out;
}

.battle-avatar.defending {
  animation: defend 0.5s ease-in-out;
}

@keyframes attack {
  0% { transform: scale(1); }
  50% { transform: scale(1.2) translateX(20px); }
  100% { transform: scale(1); }
}

@keyframes defend {
  0% { transform: scale(1); }
  25% { transform: scale(0.9); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.hp-bar {
  width: 120px;
  height: 20px;
  background: #333;
  border: 2px solid #fff;
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 5px;
}

.hp-fill {
  height: 100%;
  background: linear-gradient(45deg, #2ed573, #00ff00);
  transition: width 0.5s ease;
  border-radius: 8px;
}

.hp-text {
  font-size: 14px;
  font-weight: bold;
  color: #fff;
}

.battle-vs {
  font-size: 28px;
  color: #ff4757;
  font-weight: bold;
  text-shadow: 0 0 20px #ff4757;
}

.battle-actions {
  display: flex;
  gap: 15px;
  justify-content: center;
  margin-top: 20px;
}

.battle-action-btn {
  background: linear-gradient(45deg, #ff4757, #ff6b6b);
  border: none;
  padding: 12px 20px;
  color: white;
  border-radius: 15px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s ease;
  min-width: 100px;
}

.battle-action-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 8px 25px rgba(255, 71, 87, 0.5);
}

.battle-log {
  background: rgba(0, 0, 0, 0.4);
  padding: 15px;
  border-radius: 10px;
  margin: 15px 0;
  min-height: 80px;
  border: 1px solid rgba(255, 71, 87, 0.3);
  text-align: left;
  font-size: 14px;
  overflow-y: auto;
  max-height: 120px;
}

/* Message Box */
.message-box {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(145deg, rgba(26, 26, 46, 0.98), rgba(22, 33, 62, 0.98));
  border: 3px solid #00f5ff;
  border-radius: 15px;
  padding: 20px 25px;
  color: #fff;
  font-size: clamp(14px, 3.5vw, 16px);
  text-align: center;
  z-index: 2500;
  display: none;
  backdrop-filter: blur(15px);
  box-shadow: 0 0 50px rgba(0, 245, 255, 0.6);
  max-width: 80%;
  width: 300px;
}

/* Game Info */
.game-info {
  text-align: center;
  font-size: clamp(14px, 3.5vw, 18px);
  margin: 15px 0;
  color: #00f5ff;
  font-weight: bold;
  padding: 10px 15px;
  background: rgba(26, 26, 46, 0.3);
  border-radius: 15px;
  border: 2px solid rgba(0, 245, 255, 0.3);
  backdrop-filter: blur(10px);
  max-width: 400px;
  width: 100%;
}

.back-btn {
  background: linear-gradient(45deg, #666, #888);
  border: none;
  padding: 10px 20px;
  color: white;
  border-radius: 15px;
  cursor: pointer;
  margin: 20px auto;
  display: block;
  font-size: clamp(14px, 3.5vw, 16px);
  font-weight: bold;
  transition: all 0.3s ease;
}

.close-btn {
  background: #ff4757;
  border: none;
  padding: 6px 12px;
  color: white;
  border-radius: 8px;
  cursor: pointer;
  float: right;
  margin-bottom: 10px;
  font-weight: bold;
  font-size: clamp(12px, 3vw, 14px);
}

/* Other panels */
.chance-card, .jail-panel {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  border-radius: 20px;
  padding: 25px;
  z-index: 2000;
  display: none;
  width: 90%;
  max-width: 400px;
  text-align: center;
  backdrop-filter: blur(15px);
}

.chance-card {
  background: linear-gradient(145deg, rgba(153, 50, 204, 0.95), rgba(139, 0, 139, 0.95));
  border: 3px solid #ffd700;
  box-shadow: 0 0 50px rgba(255, 215, 0, 0.4);
}

.jail-panel {
  background: linear-gradient(145deg, rgba(220, 20, 60, 0.95), rgba(178, 34, 34, 0.95));
  border: 3px solid #fff;
  box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
  color: #fff;
}

.jail-buttons {
  display: flex;
  gap: 10px;
  justify-content: center;
  margin-top: 15px;
  flex-wrap: wrap;
}

.jail-btn {
  background: linear-gradient(45deg, #ffa500, #ff8c00);
  border: none;
  padding: 10px 15px;
  color: white;
  border-radius: 10px;
  cursor: pointer;
  font-size: clamp(12px, 3vw, 14px);
  transition: all 0.3s ease;
  font-weight: bold;
  min-width: 100px;
}

.jail-btn:hover {
  transform: scale(1.05);
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .container {
    padding: 5px;
  }
  
  .dice-section {
    padding: 10px;
    gap: 8px;
  }
  
  .player-info {
    min-width: 100px;
    padding: 8px;
  }
  
  .board {
    margin-bottom: 15px;
  }
  
  .upgrade-options {
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
  }
  
  .jail-buttons {
    flex-direction: column;
    gap: 8px;
  }
  
  .battle-field {
    flex-direction: column;
    gap: 15px;
  }
  
  .battle-actions {
    flex-wrap: wrap;
    gap: 10px;
  }
  
  .property-grid {
    grid-template-columns: repeat(3, 1fr);
  }
}

@media (max-width: 480px) {
  .dice-section {
    gap: 5px;
  }
  
  .player-info {
    min-width: 80px;
    padding: 6px;
  }
  
  .upgrade-options {
    grid-template-columns: 1fr;
  }
  
  .dice-area {
    gap: 8px;
  }
  
  .property-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}
</style>
</head>
<body>

<div class="container">
  <h1>🐉 KRYPTOMON MONOPOLY 🐉</h1>
  
  <!-- Menu Screen -->
  <div id="menu" class="menu">
    <button onclick="startGame()">🎮 Start Game</button>
    <button onclick="showRules()">📖 How to Play</button>
    <button onclick="exitGame()">❌ Exit</button>
  </div>

  <!-- Game Screen -->
  <div id="game" class="game-container">
    <div class="game-layout">
      <!-- Game Board -->
      <div class="board-container">
        <div id="board" class="board"></div>
        
        <!-- Dice Section with Player Info -->
        <div class="dice-section">
          <!-- Left Player Info -->
          <div id="playerInfo" class="player-info">
            <div class="player-avatar player"></div>
            <div class="player-name">👤 YOU</div>
            <div class="player-money">💰 $<span id="playerMoney">1500</span></div>
            <div class="player-properties">Props: <span id="playerProps">0</span></div>
          </div>
          
          <!-- Dice Area -->
          <div class="dice-area">
            <div class="dice-container">
              <div id="dice1" class="dice">1</div>
              <div id="dice2" class="dice">1</div>
            </div>
            <button id="rollBtn" class="roll-btn" onclick="rollDice()">🎲 ROLL</button>
          </div>
          
          <!-- Right Player Info -->
          <div id="cpuInfo" class="player-info">
            <div class="player-avatar cpu"></div>
            <div class="player-name">🤖 CPU</div>
            <div class="player-money">💰 $<span id="cpuMoney">1500</span></div>
            <div class="player-properties">Props: <span id="cpuProps">0</span></div>
          </div>
        </div>

        <div id="gameInfo" class="game-info">Your Turn - Roll the Dice!</div>
      </div>
    </div>

    <button class="back-btn" onclick="backToMenu()">← Back to Menu</button>
  </div>

  <!-- Purchase Panel -->
  <div id="purchasePanel" class="purchase-panel">
    <button class="close-btn" onclick="closePurchasePanel()">✕</button>
    <div class="purchase-title">Property Options</div>
    <div class="property-details">
      <p><strong>Property:</strong> <span id="propertyName">-</span></p>
      <p><strong>Price:</strong> $<span id="propertyPrice">0</span></p>
      <p><strong>Current Rent:</strong> $<span id="currentRentDisplay">0</span></p>
    </div>
    <div class="upgrade-options" id="upgradeOptions">
      <button class="upgrade-btn" id="buyBtn" onclick="buyProperty()">Buy Property<br>$<span id="buyPrice">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(1)">Level 1 🏠<br>$50<br>Rent: $<span id="rent1">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(2)">Level 2 🏠🏠<br>$100<br>Rent: $<span id="rent2">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(3)">Level 3 🏠🏠🏠<br>$150<br>Rent: $<span id="rent3">0</span></button>
      <button class="upgrade-btn" onclick="upgradeProperty(4)">Level 4 🏠🏠🏠🏠<br>$200<br>Rent: $<span id="rent4">0</span></button>
      <button class="upgrade-btn hotel-btn" onclick="buildHotel()">Hotel 🏨<br>$300<br>Rent: $<span id="rentHotel">0</span></button>
      <button class="upgrade-btn battle-btn" id="battleBtn" onclick="startBattle()" style="display: none;">⚔️ Battle for Property!</button>
    </div>
    <button class="skip-btn" onclick="skipPurchase()">Skip</button>
  </div>

  <!-- Airport Selection Panel -->
  <div id="airportPanel" class="airport-panel">
    <div class="airport-title">✈️ AIRPORT - Choose Destination</div>
    <p style="margin-bottom: 15px;">Select a property to travel to:</p>
    <div class="property-grid" id="propertyGrid"></div>
    <button class="skip-btn" onclick="closeAirportPanel()">Cancel</button>
  </div>

  <!-- Sell Properties Panel -->
  <div id="sellPanel" class="sell-panel">
    <div class="sell-title">💸 SELL PROPERTIES</div>
    <div class="sell-info">
      <p><strong>You need:</strong> $<span id="neededMoney">0</span></p>
      <p><strong>Your money:</strong> $<span id="currentMoney">0</span></p>
      <p><strong>Missing:</strong> $<span id="missingMoney">0</span></p>
    </div>
    <div class="property-list" id="propertyList"></div>
    <button class="skip-btn" onclick="declareBankruptcy()">Declare Bankruptcy</button>
  </div>

  <!-- Battle Arena -->
  <div id="battleArena" class="battle-arena">
    <div class="battle-title">⚔️ KRYPTOMON BATTLE ⚔️</div>
    
    <div class="battle-field">
      <div class="battle-player">
        <div class="battle-avatar player" id="playerBattleAvatar"></div>
        <div class="hp-bar">
          <div class="hp-fill" id="playerHpBar" style="width: 100%;"></div>
        </div>
        <div class="hp-text"><span id="playerBattleHp">100</span>/100 HP</div>
        <div style="color: #00f5ff; font-weight: bold;">YOU</div>
      </div>
      
      <div class="battle-vs">VS</div>
      
      <div class="battle-player">
        <div class="battle-avatar cpu" id="cpuBattleAvatar"></div>
        <div class="hp-bar">
          <div class="hp-fill" id="cpuHpBar" style="width: 100%;"></div>
        </div>
        <div class="hp-text"><span id="cpuBattleHp">100</span>/100 HP</div>
        <div style="color: #2ed573; font-weight: bold;">CPU</div>
      </div>
    </div>
    
    <div class="battle-log" id="battleLog">
      Battle begins! Choose your action!
    </div>
    
    <div class="battle-actions" id="battleActions">
      <button class="battle-action-btn" onclick="battleAction('attack')">🗡️ Attack</button>
      <button class="battle-action-btn" onclick="battleAction('defend')">🛡️ Defend</button>
      <button class="battle-action-btn" onclick="battleAction('magic')">✨ Magic</button>
    </div>
  </div>

  <!-- Chance Card -->
  <div id="chanceCard" class="chance-card">
    <h2>🎲 CHANCE 🎲</h2>
    <div id="chanceText"></div>
    <button class="jail-btn" onclick="closeChanceCard()" style="margin-top: 15px;">OK</button>
  </div>

  <!-- Jail Panel -->
  <div id="jailPanel" class="jail-panel">
    <h2>🔒 JAIL 🔒</h2>
    <div id="jailText">You are in jail!</div>
    <div class="jail-buttons">
      <button class="jail-btn" onclick="payJailFine()">Pay $200 Fine</button>
      <button class="jail-btn" onclick="tryJailRoll()">Try Double Roll</button>
    </div>
  </div>

  <!-- Message Box -->
  <div id="messageBox" class="message-box"></div>
</div>

<script>
// Game State
let gameState = {
  currentPlayer: 0,
  players: [
    { 
      name: 'You', 
      money: 1500, 
      position: 0, 
      properties: {}, 
      bankrupt: false, 
      inJail: false, 
      jailTurns: 0,
      jailFreeCard: false,
      hp: 100
    },
    { 
      name: 'CPU', 
      money: 1500, 
      position: 0, 
      properties: {}, 
      bankrupt: false, 
      inJail: false, 
      jailTurns: 0,
      jailFreeCard: false,
      hp: 100
    }
  ],
  gameStarted: false,
  canRoll: true,
  lastRoll: [0, 0],
  waitingForPlayer: false,
  currentPropertyIndex: -1,
  battleInProgress: false
};

// Perfect 5x5 square board with elements - Fixed layout
const boardPositions = [
  // Bottom row (0-4)
  { name: 'START', type: 'start', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Aelum Valley', type: 'property', price: 100, baseRent: 20, element: 'earth' },
  { name: 'CHANCE', type: 'chance', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Sha Mountains', type: 'property', price: 120, baseRent: 25, element: 'earth' },
  { name: 'JAIL', type: 'jail', price: 0, baseRent: 0, element: 'neutral' },
  
  // Right column (5-7)
  { name: 'Oura Canyon', type: 'property', price: 140, baseRent: 30, element: 'fire' },
  { name: 'AIRPORT', type: 'airport', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Ukko Desert', type: 'property', price: 160, baseRent: 35, element: 'fire' },
  
  // Top row (8-11)
  { name: 'FREE PARKING', type: 'special', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Haamu Peaks', type: 'property', price: 180, baseRent: 40, element: 'ice' },
  { name: 'TAX', type: 'tax', price: 0, baseRent: 0, element: 'neutral' },
  { name: 'Bosco Valley', type: 'property', price: 200, baseRent: 45, element: 'water' },
  
  // Left column (12-15)
  { name: 'Mystic Woods', type: 'property', price: 220, baseRent: 50, element: 'dark' },
  { name: 'Cryonia', type: 'property', price: 240, baseRent: 55, element: 'crystal' },
  { name: 'Sky Temple', type: 'property', price: 260, baseRent: 60, element: 'air' },
  { name: 'Thunder Peak', type: 'property', price: 280, baseRent: 65, element: 'thunder' }
];

// Reduced chance cards (half rewards)
const chanceCards = [
  { text: "Get out of jail free! Keep this card.", effect: "jailFree" },
  { text: "Collect $100 from bank!", effect: "collect100" },
  { text: "Go to jail! Do not pass START.", effect: "goToJail" },
  { text: "Advance to START! Collect $100.", effect: "goToStart" },
  { text: "Pay $25 tax!", effect: "pay25" },
  { text: "Collect $50 bonus!", effect: "collect50" }
];

// Battle system - Fixed!
const battleActions = {
  attack: { name: 'Attack', minDamage: 15, maxDamage: 35 },
  defend: { name: 'Defend', minDamage: 5, maxDamage: 15, shield: true },
  magic: { name: 'Magic', minDamage: 20, maxDamage: 45, magical: true }
};

function initGame() {
  createBoard();
  updateDisplay();
  updateGameInfo();
}

function createBoard() {
  const board = document.getElementById('board');
  board.innerHTML = '';
  
  // 5x5 grid (25 cells total, 16 used for board)
  for (let i = 0; i < 25; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    
    const boardIndex = getBoardIndex(i);
    
    if (boardIndex !== -1) {
      const position = boardPositions[boardIndex];
      
      // Add type classes
      if (position.type === 'start') cell.classList.add('start');
      else if (position.type === 'jail') cell.classList.add('jail');
      else if (position.type === 'chance') cell.classList.add('chance');
      else if (position.type === 'tax') cell.classList.add('tax');
      else if (position.type === 'airport') cell.classList.add('airport');
      
      // Add element classes for properties
      if (position.element && position.element !== 'neutral') {
        cell.classList.add(position.element);
      }
      
      cell.innerHTML = `<div class="cell-name">${position.name}</div>`;
      cell.dataset.position = boardIndex;
      
      if (position.type === 'property') {
        const rentDiv = document.createElement('div');
        rentDiv.className = 'cell-rent';
        rentDiv.textContent = `$${position.baseRent}`;
        cell.appendChild(rentDiv);
      }
    } else {
      cell.classList.add('empty');
    }
    
    board.appendChild(cell);
  }
  
  updateTokens();
  updatePropertyDisplay();
}

function getBoardIndex(gridIndex) {
  // Perfect 5x5 square mapping
  const gridToBoardMap = {
    // Bottom row (0-4)
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
    // Right column (5-7) 
    9: 5, 14: 6, 19: 7,
    // Top row (8-11)
    24: 8, 23: 9, 22: 10, 21: 11,
    // Left column (12-15)
    20: 12, 15: 13, 10: 14, 5: 15
  };
  
  return gridToBoardMap[gridIndex] || -1;
}

function updateTokens() {
  document.querySelectorAll('.player-token').forEach(token => token.remove());
  
  gameState.players.forEach((player, index) => {
    if (!player.bankrupt) {
      const cell = document.querySelector(`[data-position="${player.position}"]`);
      if (cell) {
        const token = document.createElement('div');
        token.className = `player-token token-${index === 0 ? 'player' : 'cpu'}`;
        cell.appendChild(token);
      }
    }
  });
}

function updatePropertyDisplay() {
  boardPositions.forEach((position, index) => {
    if (position.type === 'property') {
      const cell = document.querySelector(`[data-position="${index}"]`);
      if (cell) {
        // Remove old displays
        const oldOwner = cell.querySelector('.owner-tag');
        const oldBuilding = cell.querySelector('.cell-building');
        const oldRent = cell.querySelector('.cell-rent');
        
        if (oldOwner) oldOwner.remove();
        if (oldBuilding) oldBuilding.remove();
        if (oldRent) oldRent.remove();
        
        const propertyData = getPropertyData(index);
        
        // Add rent display
        const rentDiv = document.createElement('div');
        rentDiv.className = 'cell-rent';
        rentDiv.textContent = `$${calculateRent(index)}`;
        cell.appendChild(rentDiv);
        
        if (propertyData.owner !== undefined) {
          // Add owner tag
          const ownerTag = document.createElement('div');
          ownerTag.className = `owner-tag owner-${propertyData.owner === 0 ? 'player' : 'cpu'}`;
          ownerTag.textContent = propertyData.owner === 0 ? 'P' : 'C';
          cell.appendChild(ownerTag);
          
          // Add building display
          if (propertyData.level > 0) {
            const building = document.createElement('div');
            building.className = 'cell-building';
            if (propertyData.hotel) {
              building.textContent = '🏨';
            } else {
              building.textContent = '🏠'.repeat(propertyData.level);
            }
            cell.appendChild(building);
          }
        }
      }
    }
  });
}

function updateDisplay() {
  // Update player money and properties
  document.getElementById('playerMoney').textContent = gameState.players[0].money;
  document.getElementById('cpuMoney').textContent = gameState.players[1].money;
  
  // Count properties
  const playerProps = Object.keys(gameState.players[0].properties).length;
  const cpuProps = Object.keys(gameState.players[1].properties).length;
  
  document.getElementById('playerProps').textContent = playerProps;
  document.getElementById('cpuProps').textContent = cpuProps;
  
  // Update active player
  const playerInfo = document.getElementById('playerInfo');
  const cpuInfo = document.getElementById('cpuInfo');
  
  if (gameState.currentPlayer === 0) {
    playerInfo.classList.add('active');
    cpuInfo.classList.remove('active');
  } else {
    cpuInfo.classList.add('active');
    playerInfo.classList.remove('active');
  }
  
  updatePropertyDisplay();
  checkWinConditions();
}

function updateGameInfo(message = '') {
  const gameInfo = document.getElementById('gameInfo');
  if (message) {
    gameInfo.textContent = message;
  } else {
    const currentPlayerName = gameState.players[gameState.currentPlayer].name;
    gameInfo.textContent = `${currentPlayerName}'s Turn`;
  }
}

function getPropertyData(positionIndex) {
  for (let i = 0; i < gameState.players.length; i++) {
    if (gameState.players[i].properties[positionIndex]) {
      return gameState.players[i].properties[positionIndex];
    }
  }
  return { owner: undefined, level: 0, hotel: false };
}

function calculateRent(positionIndex) {
  const position = boardPositions[positionIndex];
  const propertyData = getPropertyData(positionIndex);
  
  if (propertyData.owner === undefined) {
    return position.baseRent;
  }
  
  let rent = position.baseRent;
  
  if (propertyData.hotel) {
    rent = position.baseRent * 8; // Hotel multiplier
  } else if (propertyData.level > 0) {
    rent = position.baseRent * (1 + propertyData.level); // Level multiplier
  }
  
  return rent;
}

function checkWinConditions() {
  // Check bankruptcy
  if (gameState.players[0].bankrupt) {
    showMessage('💀 You went bankrupt! CPU wins!');
    setTimeout(() => backToMenu(), 3000);
    return;
  }
  
  if (gameState.players[1].bankrupt) {
    showMessage('🎉 CPU went bankrupt! You win!');
    setTimeout(() => backToMenu(), 3000);
    return;
  }
  
  // Check monopoly (owning all properties of same element)
  const elements = ['earth', 'fire', 'ice', 'water', 'dark', 'crystal', 'air', 'thunder'];
  
  for (let element of elements) {
    const elementProperties = boardPositions
      .map((pos, index) => ({ ...pos, index }))
      .filter(pos => pos.element === element && pos.type === 'property');
    
    if (elementProperties.length > 1) {
      const playerOwns = elementProperties.every(prop => 
        gameState.players[0].properties[prop.index]
      );
      
      const cpuOwns = elementProperties.every(prop => 
        gameState.players[1].properties[prop.index]
      );
      
      if (playerOwns) {
        showMessage(`🎉 You achieved ${element} monopoly! You win!`);
        setTimeout(() => backToMenu(), 3000);
        return;
      }
      
      if (cpuOwns) {
        showMessage(`💀 CPU achieved ${element} monopoly! CPU wins!`);
        setTimeout(() => backToMenu(), 3000);
        return;
      }
    }
  }
}

function startGame() {
  document.getElementById('menu').style.display = 'none';
  document.getElementById('game').style.display = 'block';
  gameState.gameStarted = true;
  initGame();
  showMessage('Game Started! Roll the dice to begin!');
}

function backToMenu() {
  document.getElementById('game').style.display = 'none';
  document.getElementById('menu').style.display = 'block';
  resetGame();
}

function resetGame() {
  gameState = {
    currentPlayer: 0,
    players: [
      { 
        name: 'You', 
        money: 1500, 
        position: 0, 
        properties: {}, 
        bankrupt: false, 
        inJail: false, 
        jailTurns: 0,
        jailFreeCard: false,
        hp: 100
      },
      { 
        name: 'CPU', 
        money: 1500, 
        position: 0, 
        properties: {}, 
        bankrupt: false, 
        inJail: false, 
        jailTurns: 0,
        jailFreeCard: false,
        hp: 100
      }
    ],
    gameStarted: false,
    canRoll: true,
    lastRoll: [0, 0],
    waitingForPlayer: false,
    currentPropertyIndex: -1,
    battleInProgress: false
  };
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function showMessage(message) {
  const messageBox = document.getElementById('messageBox');
  messageBox.textContent = message;
  messageBox.style.display = 'block';
  
  setTimeout(() => {
    messageBox.style.display = 'none';
  }, 2500);
}

async function rollDice() {
  if (!gameState.canRoll || gameState.waitingForPlayer || gameState.battleInProgress) return;
  
  // Only current player can roll
  if ((gameState.currentPlayer === 0 && !event.isTrusted) || 
      (gameState.currentPlayer === 1)) {
    return;
  }
  
  const currentPlayer = gameState.players[gameState.currentPlayer];
  
  if (currentPlayer.inJail) {
    showJailPanel();
    return;
  }
  
  gameState.canRoll = false;
  const dice1 = document.getElementById('dice1');
  const dice2 = document.getElementById('dice2');
  const rollBtn = document.getElementById('rollBtn');
  
  dice1.classList.add('rolling');
  dice2.classList.add('rolling');
  rollBtn.disabled = true;
  
  let d1, d2;
  for (let i = 0; i < 8; i++) {
    d1 = Math.floor(Math.random() * 6) + 1;
    d2 = Math.floor(Math.random() * 6) + 1;
    dice1.textContent = d1;
    dice2.textContent = d2;
    await sleep(100);
  }
  
  gameState.lastRoll = [d1, d2];
  const rollResult = d1 + d2;
  
  dice1.classList.remove('rolling');
  dice2.classList.remove('rolling');
  
  updateGameInfo(`${currentPlayer.name} rolled ${d1} + ${d2} = ${rollResult}`);
  
  await movePlayer(gameState.currentPlayer, rollResult);
  await handleLanding();
  
  if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
    nextTurn();
  }
}

async function movePlayer(playerIndex, steps) {
  const player = gameState.players[playerIndex];
  const startPos = player.position;
  
  for (let i = 0; i < steps; i++) {
    player.position = (player.position + 1) % boardPositions.length;
    updateTokens();
    await sleep(200);
  }
  
  // Check if passed START - reduced to $100
  if (startPos + steps >= boardPositions.length || (startPos > player.position && steps < boardPositions.length)) {
    player.money += 100;
    showMessage(`${player.name} passed START and collected $100!`);
    await sleep(1000);
  }
}

async function handleLanding() {
  const player = gameState.players[gameState.currentPlayer];
  const position = boardPositions[player.position];
  
  updateDisplay();
  
  if (position.type === 'property') {
    await handlePropertyLanding(player, player.position, position);
  } else if (position.type === 'chance') {
    await handleChanceLanding();
  } else if (position.type === 'tax') {
    player.money -= 100;
    showMessage(`${player.name} paid $100 tax!`);
    await sleep(1500);
  } else if (position.type === 'airport') {
    await handleAirportLanding();
  }
  
  updateDisplay();
}

async function handlePropertyLanding(player, positionIndex, position) {
  const propertyData = getPropertyData(positionIndex);
  
  if (propertyData.owner === undefined) {
    // Property available for purchase
    if (gameState.currentPlayer === 0) {
      // Human player
      gameState.waitingForPlayer = true;
      showPurchasePanel(positionIndex, position, true);
    } else {
      // CPU player - auto decide (hidden from player)
      if (player.money >= position.price * 1.2) {
        await sleep(1000);
        buyPropertyCPU(positionIndex);
        showMessage(`CPU bought ${position.name} for $${position.price}!`);
        await sleep(2000);
      }
    }
  } else if (propertyData.owner !== gameState.currentPlayer) {
    // Pay rent or battle
    const rent = calculateRent(positionIndex);
    
    if (gameState.currentPlayer === 0) {
      // Human player - show options
      gameState.waitingForPlayer = true;
      gameState.currentPropertyIndex = positionIndex;
      showPurchasePanel(positionIndex, position, false);
    } else {
      // CPU pays rent
      if (player.money >= rent) {
        player.money -= rent;
        gameState.players[propertyData.owner].money += rent;
        showMessage(`CPU paid $${rent} rent!`);
        await sleep(2000);
      } else {
        await handleBankruptcy(gameState.currentPlayer, rent);
      }
    }
  } else {
    // Own property - show upgrade options
    if (gameState.currentPlayer === 0) {
      gameState.waitingForPlayer = true;
      showPurchasePanel(positionIndex, position, false);
    } else {
      // CPU upgrade logic
      const property = gameState.players[1].properties[positionIndex];
      if (property && property.level < 4 && !property.hotel && player.money >= 150) {
        if (Math.random() > 0.6) {
          await sleep(500);
          upgradePropertyCPU(positionIndex, property.level + 1);
          showMessage(`CPU upgraded ${position.name}!`);
          await sleep(1500);
        }
      }
    }
  }
}

async function handleChanceLanding() {
  const card = chanceCards[Math.floor(Math.random() * chanceCards.length)];
  const player = gameState.players[gameState.currentPlayer];
  
  document.getElementById('chanceText').textContent = card.text;
  document.getElementById('chanceCard').style.display = 'block';
  
  // Wait for user to close card
  await new Promise(resolve => {
    window.closeChanceCard = () => {
      document.getElementById('chanceCard').style.display = 'none';
      resolve();
    };
  });
  
  // Apply effect
  switch (card.effect) {
    case 'jailFree':
      player.jailFreeCard = true;
      break;
    case 'collect100':
      player.money += 100;
      break;
    case 'goToJail':
      player.inJail = true;
      player.position = 4; // Jail position
      player.jailTurns = 0;
      updateTokens();
      break;
    case 'goToStart':
      player.position = 0;
      player.money += 100;
      updateTokens();
      break;
    case 'pay25':
      player.money -= 25;
      break;
    case 'collect50':
      player.money += 50;
      break;
  }
  
  updateDisplay();
}

async function handleAirportLanding() {
  if (gameState.currentPlayer === 0) {
    // Human player - show airport panel
    gameState.waitingForPlayer = true;
    showAirportPanel();
  } else {
    // CPU - random property selection
    const properties = boardPositions
      .map((pos, index) => ({ ...pos, index }))
      .filter(pos => pos.type === 'property');
    
    const randomProperty = properties[Math.floor(Math.random() * properties.length)];
    gameState.players[1].position = randomProperty.index;
    updateTokens();
    showMessage(`CPU flew to ${randomProperty.name}!`);
    await sleep(2000);
  }
}

function showAirportPanel() {
  const properties = boardPositions
    .map((pos, index) => ({ ...pos, index }))
    .filter(pos => pos.type === 'property');
  
  const propertyGrid = document.getElementById('propertyGrid');
  propertyGrid.innerHTML = '';
  
  properties.forEach(property => {
    const button = document.createElement('button');
    button.className = 'property-option';
    button.textContent = property.name;
    button.onclick = () => selectAirportDestination(property.index);
    propertyGrid.appendChild(button);
  });
  
  document.getElementById('airportPanel').style.display = 'block';
}

function selectAirportDestination(propertyIndex) {
  gameState.players[gameState.currentPlayer].position = propertyIndex;
  updateTokens();
  closeAirportPanel();
  
  // Handle landing on selected property
  setTimeout(async () => {
    await handleLanding();
    if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
      nextTurn();
    }
  }, 500);
}

function closeAirportPanel() {
  document.getElementById('airportPanel').style.display = 'none';
  gameState.waitingForPlayer = false;
}

async function handleBankruptcy(playerIndex, debt) {
  const player = gameState.players[playerIndex];
  
  if (playerIndex === 0) {
    // Human player - show sell panel
    showSellPanel(debt);
  } else {
    // CPU - automatically sell properties
    const properties = Object.keys(player.properties);
    let totalValue = 0;
    
    for (let propIndex of properties) {
      const position = boardPositions[propIndex];
      const propertyData = player.properties[propIndex];
      let value = Math.floor(position.price * 0.7);
      
      if (propertyData.hotel) value += 200;
      else value += propertyData.level * 30;
      
      totalValue += value;
      delete player.properties[propIndex];
      
      if (player.money + totalValue >= debt) break;
    }
    
    player.money += totalValue;
    
    if (player.money >= debt) {
      player.money -= debt;
      gameState.players[1 - playerIndex].money += debt;
      showMessage(`CPU sold properties and paid $${debt}!`);
    } else {
      player.bankrupt = true;
      showMessage(`CPU went bankrupt!`);
    }
    
    updatePropertyDisplay();
    await sleep(2000);
  }
}

function showSellPanel(debt) {
  const player = gameState.players[0];
  
  document.getElementById('neededMoney').textContent = debt;
  document.getElementById('currentMoney').textContent = player.money;
  document.getElementById('missingMoney').textContent = Math.max(0, debt - player.money);
  
  const propertyList = document.getElementById('propertyList');
  propertyList.innerHTML = '';
  
  Object.keys(player.properties).forEach(propIndex => {
    const position = boardPositions[propIndex];
    const propertyData = player.properties[propIndex];
    
    let value = Math.floor(position.price * 0.7);
    if (propertyData.hotel) value += 200;
    else value += propertyData.level * 30;
    
    const item = document.createElement('div');
    item.className = 'property-sell-item';
    item.innerHTML = `
      <div>
        <strong>${position.name}</strong><br>
        Sell for: $${value}
      </div>
      <button class="sell-property-btn" onclick="sellProperty(${propIndex}, ${value})">
        Sell
      </button>
    `;
    
    propertyList.appendChild(item);
  });
  
  document.getElementById('sellPanel').style.display = 'block';
}

function sellProperty(propertyIndex, value) {
  const player = gameState.players[0];
  player.money += value;
  delete player.properties[propertyIndex];
  
  updateDisplay();
  updatePropertyDisplay();
  
  const debt = parseInt(document.getElementById('neededMoney').textContent);
  if (player.money >= debt) {
    document.getElementById('sellPanel').style.display = 'none';
    
    // Pay the debt
    player.money -= debt;
    const ownerIndex = getPropertyData(gameState.currentPropertyIndex).owner;
    gameState.players[ownerIndex].money += debt;
    
    showMessage(`You paid $${debt} rent!`);
    gameState.waitingForPlayer = false;
    
    setTimeout(() => {
      if (!gameState.battleInProgress) {
        nextTurn();
      }
    }, 2000);
  } else {
    // Update the missing money display
    document.getElementById('currentMoney').textContent = player.money;
    document.getElementById('missingMoney').textContent = debt - player.money;
  }
}

function declareBankruptcy() {
  gameState.players[0].bankrupt = true;
  document.getElementById('sellPanel').style.display = 'none';
  showMessage('You declared bankruptcy!');
  updateDisplay();
}

function showPurchasePanel(positionIndex, position, canBuy) {
  gameState.currentPropertyIndex = positionIndex;
  const propertyData = getPropertyData(positionIndex);
  
  document.getElementById('propertyName').textContent = position.name;
  document.getElementById('propertyPrice').textContent = position.price;
  document.getElementById('currentRentDisplay').textContent = calculateRent(positionIndex);
  
  const upgradeOptions = document.getElementById('upgradeOptions');
  const buyBtn = document.getElementById('buyBtn');
  const battleBtn = document.getElementById('battleBtn');
  
  // Hide all options first
  upgradeOptions.querySelectorAll('.upgrade-btn').forEach(btn => {
    if (!btn.classList.contains('battle-btn')) {
      btn.style.display = 'none';
    }
  });
  battleBtn.style.display = 'none';
  
  if (canBuy && propertyData.owner === undefined) {
    // Show buy option
    buyBtn.style.display = 'block';
    document.getElementById('buyPrice').textContent = position.price;
    
    if (gameState.players[gameState.currentPlayer].money < position.price) {
      buyBtn.disabled = true;
    } else {
      buyBtn.disabled = false;
    }
  } else if (propertyData.owner === gameState.currentPlayer) {
    // Show upgrade options for own property
    const property = gameState.players[gameState.currentPlayer].properties[positionIndex];
    
    for (let level = 1; level <= 4; level++) {
      const btn = upgradeOptions.querySelector(`[onclick="upgradeProperty(${level})"]`);
      if (btn) {
        btn.style.display = 'block';
        const cost = level * 50;
        const rent = position.baseRent * (1 + level);
        
        btn.querySelector(`#rent${level}`).textContent = rent;
        
        if (property.level >= level || gameState.players[gameState.currentPlayer].money < cost) {
          btn.disabled = true;
        } else {
          btn.disabled = false;
        }
      }
    }
    
    // Hotel option
    const hotelBtn = upgradeOptions.querySelector('[onclick="buildHotel()"]');
    if (hotelBtn) {
      hotelBtn.style.display = 'block';
      const hotelRent = position.baseRent * 8;
      document.getElementById('rentHotel').textContent = hotelRent;
      
      if (property.level < 4 || property.hotel || gameState.players[gameState.currentPlayer].money < 300) {
        hotelBtn.disabled = true;
      } else {
        hotelBtn.disabled = false;
      }
    }
  } else if (propertyData.owner !== undefined && propertyData.owner !== gameState.currentPlayer) {
    // Show battle option for opponent's property
    battleBtn.style.display = 'block';
  }
  
  document.getElementById('purchasePanel').style.display = 'block';
}

function buyProperty() {
  const player = gameState.players[gameState.currentPlayer];
  const position = boardPositions[gameState.currentPropertyIndex];
  
  if (player.money >= position.price) {
    player.money -= position.price;
    player.properties[gameState.currentPropertyIndex] = {
      owner: gameState.currentPlayer,
      level: 0,
      hotel: false
    };
    
    updateDisplay();
    updatePropertyDisplay();
    closePurchasePanel();
    showMessage(`You bought ${position.name} for $${position.price}!`);
  }
}

function buyPropertyCPU(positionIndex) {
  const player = gameState.players[1];
  const position = boardPositions[positionIndex];
  
  player.money -= position.price;
  player.properties[positionIndex] = {
    owner: 1,
    level: 0,
    hotel: false
  };
  
  updateDisplay();
  updatePropertyDisplay();
}

function upgradeProperty(level) {
  const player = gameState.players[gameState.currentPlayer];
  const position = boardPositions[gameState.currentPropertyIndex];
  const cost = level * 50;
  
  if (player.money >= cost) {
    player.money -= cost;
    player.properties[gameState.currentPropertyIndex].level = level;
    
    updateDisplay();
    updatePropertyDisplay();
    showMessage(`Upgraded ${position.name} to Level ${level}!`);
    
    // Update the panel to reflect new state
    showPurchasePanel(gameState.currentPropertyIndex, position, false);
  }
}

function upgradePropertyCPU(positionIndex, level) {
  const player = gameState.players[1];
  const cost = level * 50;
  
  player.money -= cost;
  player.properties[positionIndex].level = level;
  
  updateDisplay();
  updatePropertyDisplay();
}

function buildHotel() {
  const player = gameState.players[gameState.currentPlayer];
  const position = boardPositions[gameState.currentPropertyIndex];
  
  if (player.money >= 300) {
    player.money -= 300;
    player.properties[gameState.currentPropertyIndex].hotel = true;
    
    updateDisplay();
    updatePropertyDisplay();
    closePurchasePanel();
    showMessage(`Built a hotel on ${position.name}!`);
  }
}

function startBattle() {
  gameState.battleInProgress = true;
  
  // Reset HP for battle
  gameState.players[0].hp = 100;
  gameState.players[1].hp = 100;
  
  closePurchasePanel();
  showBattleArena();
}

function showBattleArena() {
  document.getElementById('playerBattleHp').textContent = gameState.players[0].hp;
  document.getElementById('cpuBattleHp').textContent = gameState.players[1].hp;
  document.getElementById('playerHpBar').style.width = '100%';
  document.getElementById('cpuHpBar').style.width = '100%';
  document.getElementById('battleLog').textContent = 'Battle begins! Choose your action!';
  
  document.getElementById('battleArena').style.display = 'block';
}

async function battleAction(action) {
  if (!battleActions[action]) return;
  
  const actionData = battleActions[action];
  const playerDamage = Math.floor(Math.random() * (actionData.maxDamage - actionData.minDamage + 1)) + actionData.minDamage;
  
  // Player attacks CPU
  gameState.players[1].hp -= playerDamage;
  if (gameState.players[1].hp < 0) gameState.players[1].hp = 0;
  
  let battleText = `You used ${actionData.name} and dealt ${playerDamage} damage!\n`;
  
  // Animate player attack
  document.getElementById('playerBattleAvatar').classList.add('attacking');
  document.getElementById('cpuBattleAvatar').classList.add('defending');
  
  setTimeout(() => {
    document.getElementById('playerBattleAvatar').classList.remove('attacking');
    document.getElementById('cpuBattleAvatar').classList.remove('defending');
  }, 800);
  
  // Update HP bars
  document.getElementById('cpuBattleHp').textContent = gameState.players[1].hp;
  document.getElementById('cpuHpBar').style.width = `${(gameState.players[1].hp / 100) * 100}%`;
  
  if (gameState.players[1].hp <= 0) {
    battleText += 'CPU defeated! You win the battle!';
    document.getElementById('battleLog').textContent = battleText;
    
    setTimeout(() => {
      endBattle(true);
    }, 2000);
    return;
  }
  
  // CPU counter-attack
  await sleep(1000);
  
  const cpuActions = Object.keys(battleActions);
  const cpuAction = cpuActions[Math.floor(Math.random() * cpuActions.length)];
  const cpuActionData = battleActions[cpuAction];
  const cpuDamage = Math.floor(Math.random() * (cpuActionData.maxDamage - cpuActionData.minDamage + 1)) + cpuActionData.minDamage;
  
  gameState.players[0].hp -= cpuDamage;
  if (gameState.players[0].hp < 0) gameState.players[0].hp = 0;
  
  battleText += `CPU used ${cpuActionData.name} and dealt ${cpuDamage} damage!`;
  
  // Animate CPU attack
  document.getElementById('cpuBattleAvatar').classList.add('attacking');
  document.getElementById('playerBattleAvatar').classList.add('defending');
  
  setTimeout(() => {
    document.getElementById('cpuBattleAvatar').classList.remove('attacking');
    document.getElementById('playerBattleAvatar').classList.remove('defending');
  }, 800);
  
  // Update HP bars
  document.getElementById('playerBattleHp').textContent = gameState.players[0].hp;
  document.getElementById('playerHpBar').style.width = `${(gameState.players[0].hp / 100) * 100}%`;
  
  if (gameState.players[0].hp <= 0) {
    battleText += '\nYou were defeated! CPU wins the battle!';
    document.getElementById('battleLog').textContent = battleText;
    
    setTimeout(() => {
      endBattle(false);
    }, 2000);
    return;
  }
  
  document.getElementById('battleLog').textContent = battleText;
}

function endBattle(playerWon) {
  document.getElementById('battleArena').style.display = 'none';
  gameState.battleInProgress = false;
  
  if (playerWon) {
    // Player can buy the property at market price
    const position = boardPositions[gameState.currentPropertyIndex];
    const propertyData = getPropertyData(gameState.currentPropertyIndex);
    const purchasePrice = position.price * 2;
    
    if (gameState.players[0].money >= purchasePrice) {
      if (confirm(`You won! Buy ${position.name} for $${purchasePrice}?`)) {
        gameState.players[0].money -= purchasePrice;
        
        // Remove from opponent
        delete gameState.players[propertyData.owner].properties[gameState.currentPropertyIndex];
        
        // Add to player
        gameState.players[0].properties[gameState.currentPropertyIndex] = {
          owner: 0,
          level: 0,
          hotel: false
        };
        
        updateDisplay();
        updatePropertyDisplay();
        showMessage(`You conquered ${position.name}!`);
      }
    } else {
      showMessage('You won but cannot afford to buy the property!');
    }
  } else {
    // Player pays double rent
    const rent = calculateRent(gameState.currentPropertyIndex) * 2;
    const propertyData = getPropertyData(gameState.currentPropertyIndex);
    
    if (gameState.players[0].money >= rent) {
      gameState.players[0].money -= rent;
      gameState.players[propertyData.owner].money += rent;
      showMessage(`You lost and paid double rent: $${rent}!`);
    } else {
      handleBankruptcy(0, rent);
      return;
    }
  }
  
  gameState.waitingForPlayer = false;
  updateDisplay();
  
  setTimeout(() => {
    nextTurn();
  }, 3000);
}

function skipPurchase() {
  closePurchasePanel();
}

function closePurchasePanel() {
  document.getElementById('purchasePanel').style.display = 'none';
  gameState.waitingForPlayer = false;
  
  if (!gameState.battleInProgress) {
    // If we were on opponent's property, pay rent
    if (gameState.currentPropertyIndex !== -1) {
      const propertyData = getPropertyData(gameState.currentPropertyIndex);
      if (propertyData.owner !== undefined && propertyData.owner !== gameState.currentPlayer) {
        const rent = calculateRent(gameState.currentPropertyIndex);
        const player = gameState.players[gameState.currentPlayer];
        
        if (player.money >= rent) {
          player.money -= rent;
          gameState.players[propertyData.owner].money += rent;
          showMessage(`${player.name} paid $${rent} rent!`);
          updateDisplay();
        } else {
          handleBankruptcy(gameState.currentPlayer, rent);
          return;
        }
      }
    }
    
    setTimeout(() => {
      nextTurn();
    }, 1500);
  }
}

function showJailPanel() {
  const player = gameState.players[gameState.currentPlayer];
  
  document.getElementById('jailText').textContent = 
    `You are in jail! Turns in jail: ${player.jailTurns + 1}/3`;
  
  document.getElementById('jailPanel').style.display = 'block';
}

function payJailFine() {
  const player = gameState.players[gameState.currentPlayer];
  
  if (player.money >= 200) {
    player.money -= 200;
    player.inJail = false;
    player.jailTurns = 0;
    
    document.getElementById('jailPanel').style.display = 'none';
    updateDisplay();
    showMessage('You paid $200 and are free!');
    
    gameState.canRoll = true;
    document.getElementById('rollBtn').disabled = false;
  } else {
    showMessage('Not enough money to pay fine!');
  }
}

async function tryJailRoll() {
  const player = gameState.players[gameState.currentPlayer];
  
  document.getElementById('jailPanel').style.display = 'none';
  
  // Roll dice
  const d1 = Math.floor(Math.random() * 6) + 1;
  const d2 = Math.floor(Math.random() * 6) + 1;
  
  document.getElementById('dice1').textContent = d1;
  document.getElementById('dice2').textContent = d2;
  
  if (d1 === d2) {
    // Exact doubles - escape!
    player.inJail = false;
    player.jailTurns = 0;
    showMessage(`Rolled doubles (${d1}, ${d2})! You escaped jail!`);
    
    await sleep(1500);
    await movePlayer(gameState.currentPlayer, d1 + d2);
    await handleLanding();
    
    if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
      nextTurn();
    }
  } else {
    player.jailTurns++;
    
    if (player.jailTurns >= 3) {
      // Must pay fine after 3 turns
      if (player.money >= 200) {
        player.money -= 200;
        player.inJail = false;
        player.jailTurns = 0;
        showMessage('3 turns in jail! Paid $200 fine and escaped!');
        
        await sleep(1500);
        await movePlayer(gameState.currentPlayer, d1 + d2);
        await handleLanding();
        
        if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
          nextTurn();
        }
      } else {
        showMessage('Cannot pay jail fine! You are bankrupt!');
        player.bankrupt = true;
        updateDisplay();
        return;
      }
    } else {
      showMessage(`No doubles (${d1}, ${d2}). Still in jail!`);
      nextTurn();
    }
  }
  
  updateDisplay();
}

function nextTurn() {
  gameState.currentPlayer = 1 - gameState.currentPlayer;
  gameState.canRoll = true;
  document.getElementById('rollBtn').disabled = false;
  
  updateDisplay();
  updateGameInfo();
  
  // CPU turn
  if (gameState.currentPlayer === 1 && !gameState.players[1].bankrupt) {
    setTimeout(async () => {
      await cpuTurn();
    }, 1000);
  }
}

async function cpuTurn() {
  updateGameInfo('CPU is thinking...');
  await sleep(1000);
  
  const currentPlayer = gameState.players[gameState.currentPlayer];
  
  if (currentPlayer.inJail) {
    // CPU jail logic
    if (currentPlayer.jailTurns >= 2 && currentPlayer.money >= 200) {
      // Pay fine if been in jail for 2+ turns
      currentPlayer.money -= 200;
      currentPlayer.inJail = false;
      currentPlayer.jailTurns = 0;
      showMessage('CPU paid $200 jail fine!');
      await sleep(1500);
    } else {
      // Try to roll doubles
      const d1 = Math.floor(Math.random() * 6) + 1;
      const d2 = Math.floor(Math.random() * 6) + 1;
      
      document.getElementById('dice1').textContent = d1;
      document.getElementById('dice2').textContent = d2;
      
      if (d1 === d2) {
        currentPlayer.inJail = false;
        currentPlayer.jailTurns = 0;
        showMessage(`CPU rolled doubles (${d1}, ${d2}) and escaped jail!`);
        
        await sleep(1500);
        await movePlayer(gameState.currentPlayer, d1 + d2);
        await handleLanding();
        
        if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
          nextTurn();
        }
        return;
      } else {
        currentPlayer.jailTurns++;
        
        if (currentPlayer.jailTurns >= 3) {
          if (currentPlayer.money >= 200) {
            currentPlayer.money -= 200;
            currentPlayer.inJail = false;
            currentPlayer.jailTurns = 0;
            showMessage('CPU forced to pay $200 after 3 turns in jail!');
            
            await sleep(1500);
            await movePlayer(gameState.currentPlayer, d1 + d2);
            await handleLanding();
            
            if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
              nextTurn();
            }
            return;
          } else {
            showMessage('CPU cannot pay jail fine and went bankrupt!');
            currentPlayer.bankrupt = true;
            updateDisplay();
            return;
          }
        } else {
          showMessage(`CPU rolled (${d1}, ${d2}) - still in jail!`);
          nextTurn();
          return;
        }
      }
    }
  }
  
  // Normal CPU turn
  const d1 = Math.floor(Math.random() * 6) + 1;
  const d2 = Math.floor(Math.random() * 6) + 1;
  const rollResult = d1 + d2;
  
  document.getElementById('dice1').textContent = d1;
  document.getElementById('dice2').textContent = d2;
  
  updateGameInfo(`CPU rolled ${d1} + ${d2} = ${rollResult}`);
  
  await movePlayer(gameState.currentPlayer, rollResult);
  await handleLanding();
  
  if (!gameState.waitingForPlayer && !gameState.battleInProgress) {
    nextTurn();
  }
}

function closeChanceCard() {
  // This function is called by the promise resolver in handleChanceLanding
}

function showRules() {
  alert(`🐉 KRYPTOMON MONOPOLY RULES 🐉

🎯 WIN CONDITIONS:
• Achieve monopoly (own all properties of same element)
• Bankrupt your opponent

🎲 GAMEPLAY:
• Roll dice to move around the board
• Buy properties and upgrade them (4 levels + hotel)
• Pay rent when landing on opponent's properties
• Collect $100 when passing START

⚔️ BATTLE SYSTEM:
• Battle for opponent's properties when you land on them
• Win battles to buy properties at 2x price
• Lose battles and pay double rent

🏛️ SPECIAL SPACES:
• START: Collect $100
• JAIL: Pay $200 fine or roll exact doubles to escape
• CHANCE: Draw random cards
• TAX: Pay $100
• AIRPORT: Choose any property to travel to

💰 BANKRUPTCY:
• Sell properties if you can't pay rent
• Declare bankruptcy if you still can't pay`);
}

function exitGame() {
  if (confirm('Are you sure you want to exit?')) {
    window.close();
  }
}

// Initialize game
document.addEventListener('DOMContentLoaded', function() {
  // Game will start when user clicks start button
});
</script>
</body>
</html>
